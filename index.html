<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Jackbox : Ruby Code Injectors: Jackbox">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Jackbox</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/LouHenryAlvarez/jackbox">View on GitHub</a>

          <h1 id="project_title">Jackbox</h1>
          <h2 id="project_tagline">Ruby Code Injectors: Jackbox</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/LouHenryAlvarez/jackbox/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/LouHenryAlvarez/jackbox/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        



<p>Copyright Â© 2014 LHA. All rights reserved.</p>

<h1>
<a id="jackbox---google" class="anchor" href="#jackbox---google" aria-hidden="true"><span class="octicon octicon-link"></span></a>Jackbox   <a href="https://plus.google.com/102732809517976898938">Google+</a>
</h1>

<p>Jackbox is a set of programming tools which enhance the Ruby language and provide additional software constructs.  </p>

<p>The main library function at this time centers around the concept of code Injectors.  To make it easier to grasp the idea behind them, these can perhaps be thought of as an <strong>extended closure</strong> or a form of closure which can also serve as module.  But, most of all Injectors propose some additional interesting properties to the idea of a mix-in.  For instance, they give your code the ability to capture your methods' surrounding context and introduce it into an indiscriminate target.  They make it possible to solve several general problems in the areas of OOP and GOF standard and traditional Ruby shortcomings with the GOF Decorator and Strategy Patterns.  They instrument control over the presence of injector code in targets with mechanisms involving injector ejection and directives.  Finally, they introduce the concept of injector versioning.  This is a feature which allows you to redefine parts of your program in local isolation and without it affecting others.  See Injector Versioning below.  </p>

<h2>
<a id="basic-methods" class="anchor" href="#basic-methods" aria-hidden="true"><span class="octicon octicon-link"></span></a>Basic Methods</h2>

<p>There are some basic Jackbox methods.  The are just rudimentary helpers, which in effect are a form of syntax sugar for every day things.  These are their descriptions:</p>

<h4>
<a id="decoratesym-blk" class="anchor" href="#decoratesym-blk" aria-hidden="true"><span class="octicon octicon-link"></span></a>#decorate(:sym, &amp;blk)</h4>

<p>This method allows for decorations to be placed on a single method, be it an instance or class method without too much fuss. It also makes possible the use of ruby's keyword :super within the body of the decorator.  Use it instead of #alias_method_chain.</p>

<p>Examples:</p>

<pre><code># some class
class One
  def foo
    'foo '
  end
end
# then...
</code></pre>

<p>At the class level during definition:</p>

<pre><code># the same class
class One
  decorate :foo do
    super() + 'decoration '                   # super available within decoration
  end
end

One.new.foo
#=&gt; foo decoration
</code></pre>

<p>At the object level during execution:</p>

<pre><code>one = One.new

one.decorate :foo do |arg|
  super() + arg                               # again the use of super is possible
end

one.foo('after')
#=&gt; foo decoration after
</code></pre>

<p>It also works like so:</p>

<pre><code>Object.decorate :inspect do
  puts super() + " is your object"
end

Object.new.inspect
#=&gt; #&lt;Object:0x00000101787e20&gt; is your object
</code></pre>

<h4>
<a id="withobj-blk" class="anchor" href="#withobj-blk" aria-hidden="true"><span class="octicon octicon-link"></span></a>#with(obj, &amp;blk)</h4>

<p>There is also a new version of the :with construct.  The important thing to remember about #with is it has a primary context which is the object passed to it, and a secondary context which is the object you are making the call from.  Here is the sample usage code:</p>

<pre><code>class One
  def foo(arg)
    'in One ' + arg
  end
end

class Two
  def faa(arg)
    'and in Two ' + arg
  end
  def meth
    with One.new do
      return foo faa 'with something'         # context of One and Two available simultaneously!!!
    end
  end
end

Two.new.meth
#=&gt; 'in One and in Two with something'
</code></pre>

<p>Use it with #decorate on singleton classes like this:</p>

<pre><code>class Dir

  with singleton_class do
    decorate :entries do |name='.', opts=nil| #:doc:
      super name, opts
    end
    decorate :new do |name, &amp;code| #:doc:
      FileUtils.mkpath name unless exists?(name)
      return Dir.open(name, &amp;code) if code
      Dir.open name
    end
  end

end
</code></pre>

<p>Or its use in the following method:</p>

<pre><code>def add_line(spec)
  open spec[:to], 'r+' do |file|
    lines = file.readlines
    file.rewind

    index = 0
    # look for the first 'require' line in file             
    lines.each_with_index { |line, i| 
      if line.match(/^require/).nil?
        break if index != i
        index = i + 1
        next
      else
        index = i
      end 
    }
    # insert our line after check to see not already there
    with lines do
      format = spec[:format] || required
      unless join.match(Regexp.new(format.join('|')))
        insert(
          index &amp;&amp; index + 1 || 0, format.last
        ) 
      end
    end

    file.write lines.join
  end
end
</code></pre>

<h4>
<a id="letssymnil-blk" class="anchor" href="#letssymnil-blk" aria-hidden="true"><span class="octicon octicon-link"></span></a>#lets(sym=nil, &amp;blk)</h4>

<p>This is simple syntax sugar.  It allows the creation of local or global procs using a more function-like syntax.  It adds readability to some constructs.  Here are some examples:</p>

<p>To define local functions/lambdas. Define symbols in local scope:</p>

<pre><code>def main
  lets bar =-&gt;(arg){ arg * arg }              # read as lets set bar to lambda/proc 

  # later on ...

  var = bar[3]                                # bar is only available within #main
  #...
end                                                         
</code></pre>

<p>As a shortcut for define_method. Use it for short functional definitions:</p>

<pre><code>lets( :meth ){ |arg| arg * 2 }                # read as lets define symbol :meth to be ....
meth(3)                                                         
# =&gt; 6 
</code></pre>

<p>Can be used to define a special values or pseudo-immutable strings:</p>

<pre><code>lets(:foo){3+Math::Pi}                        # read as lets set :foo to value
lets(:faa){ 'some important string' }
</code></pre>

<h2>
<a id="injectors" class="anchor" href="#injectors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Injectors</h2>

<p>Injectors are the main tool in Jackbox at the time of this writing --real meat of Jackbox. These again are an extended closure, a form of mix-in that has properties of both a closure and a module.  They are an extended closure if you will.  In the sections below we will discuss some of the methods available to you with Jackbox in connection with Injectors. There are some syntactical differences to Injectors with respect to regular modules.  We will show them first, with some examples: </p>

<p><strong>Injectors are declared in the following ways:</strong></p>

<pre><code>injector :name

#  or...

Name = injector :name

# or even ...

injector :Name                                # capitalized method
</code></pre>

<p>Their use and semantics are somewhat defined by the following snippet.  But, to fully understand their implications to your code, you have to understand the section on injector versioning, and perhaps injector directives. </p>

<pre><code># somewhere in your code
include Injectors

injector :my_injector                         # define the injector 

my_injector do                     
  def bar                  
    :a_bar
  end
end

# later on...
widget.enrich my_injector
widget.bar

# or...  
Mine = my_injector
class Target
  inject Mine                                 # apply the injector
end

Target.new.bar

module None
  facet :f

  class Bone
    inject None.f
  end
end

# etc ...
</code></pre>

<p><strong>Injectors can have prolongations:</strong></p>

<pre><code>my_injector do                                # first prolongation

  def another_method
  end

end

# ...

my_injector do                                # another prolongation

  def yet_another_method
  end

end
</code></pre>

<h4>
<a id="injectorsym----j" class="anchor" href="#injectorsym----j" aria-hidden="true"><span class="octicon octicon-link"></span></a>#injector(:sym)   #=&gt; j</h4>

<p>This is the main method.  It defines an object of type Injector with the name of symbol :sym.  Use it when you want to generate an Injector object for later use.  The symbol can then be used as a handle to the injector whenever you need to prolong the injector by adding methods to it or apply it to another object.</p>

<p>Here is a more interesting example:</p>

<pre><code>class ClosureExpose

    some_value = 'something'

    injector :capture do
        define_method :val do
            some_value
        end
    end

    inject capture
end

class SecondClass
    inject ClosureExpose.capture
end

# the result
SecondClass.new.val.should == 'something'
</code></pre>

<p>For all this to happen Jackbox also introduces some additional ruby constructs, namely the keywords #inject and #enrich.  These can be thought of as simply new corollaries to #include and #extend. If you're working with injectors you need to use them depending on context as some of the functionality of Injectors is related to them.</p>

<h4>
<a id="injectj" class="anchor" href="#injectj" aria-hidden="true"><span class="octicon octicon-link"></span></a>#inject(<em>j</em>)</h4>

<p>This method is analogous to ruby's #include but its use is reserved for Injectors.  The scope of this method is the same as the scope of #include, and its intended use is for class definitions. Use it to "include" an Injector into a receiving class.</p>

<h4>
<a id="enrichj" class="anchor" href="#enrichj" aria-hidden="true"><span class="octicon octicon-link"></span></a>#enrich(<em>j</em>)</h4>

<p>This method in turn is analogous to ruby's #extend. The scope of this method is also the same as that of #extend, and its intended use if for object definition.  Use it to extend the receiver of an injector.</p>

<h3>
<a id="injector-versioning" class="anchor" href="#injector-versioning" aria-hidden="true"><span class="octicon octicon-link"></span></a>Injector Versioning</h3>

<p>One of the most valuable properties of injectors is Injector Versioning.  Versioning is the term used to identify a feature in the code that produces an artifact of injection which contains a certain set of methods with their associated outputs, and represents a snapshot of that injector up until the point it's applied to an object.  From, that point on the object contains only that version of methods from that injector, and any subsequent overrides to those methods are only members of the "prolongation" of the injector and do not become part of the object of injection unless some form of re-injection occurs. Newer versions of an injector's methods only become part of newer objects or newer injections into existing targets.</p>

<p><strong>Note: One important thing to remember about versioning is that it refers to re-definitions of methods in newer prolongations of the same injector and the relationship those methods have to the other members of the version and to client code.</strong></p>

<p>We'll use some examples to illustrate the point.  This is how versioning occurs:</p>

<pre><code>#___________________
# injector declaration
injector :my_injector do                                                            
  def bar
    :a_bar                                    # version bar.1
  end
  def foo
    # ...
  end
end

enrich my_injector                            # apply --snapshot:  to any object instance
bar.should == :a_bar                          # pass the test

#__________________
# injector prolongation
my_injector do                                                                          
  def bar
    :some_larger_bar                          # version bar.2 ... re-defines bar
  end
  def some_other_function
  # ...
  end
end

bar.should == :a_bar                          # bar.1 is still the one  
</code></pre>

<p>When re-injection occurs, and only then does the new version of the #bar method come into play. Here is the code:</p>

<pre><code>#_________________
# re-injection
enrich my_injector                            # re-injection: re-apply --snapshot on any object instance

bar.should == :some_larger_bar                # bar.2 now available
expect{some_other_function}.to_not raise_error      # some_other_function.1 is also present
</code></pre>

<p>Here is an example with classes:</p>

<pre><code>#___________________
# injector declaration:
Versions = injector :versions do
  def meth arg                                # version meth.1
    arg ** arg
  end
end

class One
  inject Versions                             # apply --first snapshot
end

#_________________
# injector prolongation:                              
versions do
  def meth arg1, arg2                         # version meth.2 ... redefines meth.1
    arg1 * arg2
  end
end

class Two
  inject Versions                             # apply --second snapshot
end


# result
Two.new.meth(2,4).should == 8                 # meth.2 
                                                      # two different injector versions
One.new.meth(3).should == 27                  # meth.1
</code></pre>

<p>Re-injection on classes is a little bit trickier.  Why? Because class injection is more pervasive --we don't necessarily want to be redefining a class at every step. To re-inject a class we must use the Strategy Pattern or use a private update.  See the rspec files for more on this.  </p>

<p>Right now, we want to give some treatment to injector local binding.  That is, the binding of an injectors' methods is local to the prolongation/version in which they are located before the versioning occurs.  Here, is the code:</p>

<pre><code>#_____________________
# injector declaration
injector :functionality do
  def basic arg                               # version basic.1
    arg * 2
  end
end

o = Object.new.enrich functionality           # apply --first snapshot
o.basic(1).should == 2                        # basic.1 


#_____________________
# injector prolongation
functionality do
  def basic arg                               # basic.2 ... basic.1 redefined
    arg * 3
  end

  def compound                                # compound.1 --binding locally to basic.2 in this prolongation
    basic(3) + 2                                      
  end
end

p = Object.new.enrich(functionality)          # apply --second snapshot: like above
p.basic(1).should == 3                        # basic.2 
p.compound.should == 11                       # compound.1 

o.basic(1).should == 2                        # basic.1 --NOT basic.2: like above

                                              #####################################################
o.compound.should == 11                       # compound.1 --local binding to basic.2 NOT basic.1
                                              #####################################################
</code></pre>

<p>There is one more interesting property however. The use of #define_method to re-define methods in any prolongation updates the entire injector and all its versions.  This preserves one of the fundamental tenets of injectors: being able to take some local context, enclose it and through the injector introduce it to some indiscriminate place. Here is an example of #define_method' difference:</p>

<pre><code>SomeFacet = facet :some_facet do
    def foo_bar
        'a foo and a bar'
    end
end

class Client
    inject SomeFacet
end

Client.new.foo_bar.should == 'a foo and a bar'      # expected

some_facet do
    define_method :foo_bar do
        'fooooo and barrrrr'
    end
end

Client.new.foo_bar.should == 'fooooo and barrrrr'   # different than above
</code></pre>

<p>Injector Versioning together with injector local binding allow you to mutate injectors to fit your particular purpose at hand and keep those local modifications isolated from the rest of your program making your code to naturally evolve with your program.</p>

<h3>
<a id="multiple-injector-composition" class="anchor" href="#multiple-injector-composition" aria-hidden="true"><span class="octicon octicon-link"></span></a>Multiple Injector composition</h3>

<p>The composition of multiple injectors into an object can be specified as follows:</p>

<pre><code>include Injectors

# declare injectors
injector :FuelSystem
injector :Engines
injector :Capsule
injector :Landing

# compose the object
class SpaceShip
    inject FuelSystem()
    inject Engines()
    inject Capsule()
    inject Landing()

    def launch
        gas_tank fuel_lines burners ignition :go
        self
    end
end


# define functionality
FuelSystem do
    def gas_tank arg
        :gas
    end

    def fuel_lines arg
        :fuel
    end

    def burners arg
        :metal
    end
end

# further define function
Engines do
    def ignition arg
        :spark
    end
end

# create object
flyer = SpaceShip.new.launch

# in flight definitions, ha ha!!
Capsule do
    def o2
        :oxigen
    end
    def hydration
        :water
    end
end

# more inflight definitions
var = 'wheels'
Landing do
    define_method :gear do                    # a definintion based on available surrounding context
        var
    end
end
</code></pre>

<p><strong>IMPORTANT NOTE: Injector lookup follows the method and not the constant lookup algorithm.</strong></p>

<p>If you need to follow constant lookup, here is the code for that:</p>

<pre><code>Name = injector :sym ....
</code></pre>

<p>But, this is the basic idea here.  Using this approach Jackbox goes on to solve the Decorator Pattern problem for the Ruby language.  </p>

<h3>
<a id="the-gof-decorator-pattern" class="anchor" href="#the-gof-decorator-pattern" aria-hidden="true"><span class="octicon octicon-link"></span></a>The GOF Decorator Pattern:</h3>

<p>Traditionally this is only partially solved in Ruby through PORO decorators or the use of modules.  However, there are the problems of loss of class identity for the former and the limitations on the times it can be re-applied to the same object for the latter. With Jackbox this is solved.  An injector used as a decorator does not confuse class identity for the receiver. </p>

<p>Here is the code for that:</p>

<pre><code>class Coffee
    def cost
        1.50
    end
end

injector :milk do
    def cost
        super() + 0.30
    end
end
injector :sprinkles do
    def cost
        super() + 0.15
    end
end

cup = Coffee.new.enrich(milk).enrich(sprinkles)
cup.should be_instance_of(Coffee)

cup.cost.should == 1.95
</code></pre>

<p>Furthermore, these decorators can be re-applied multiple times to the same receiver:</p>

<pre><code>cup = Coffee.new.enrich(milk).enrich(sprinkles).enrich(sprinkles)
# or even..
cup = Coffee.new.enrich milk, sprinkles, sprinkles

cup.cost.should == 2.10
cup.should be_instance_of(Coffee)
cup.injectors.should == [:milk, :sprinkles, :sprinkles]
</code></pre>

<p>Decorators are useful in several areas of OOP: graphics, stream processing, command processors to name a few.</p>

<h3>
<a id="injector-introspection" class="anchor" href="#injector-introspection" aria-hidden="true"><span class="octicon octicon-link"></span></a>Injector introspection</h3>

<p>Injectors have the ability to speak about themselves and inject their receivers with these introspecting capabilities.  Every injected/enriched object or class can enumerate its injectors.  Moreover injectors can speak about its members just like any module or class.</p>

<pre><code>class Target
end

injector :Function do
  def far
    puts :faaaar
  end
end
injector :Style do
    def pretty
        'oohooo'
    end
end

Target.inject Function(), Style()

Target.injectors.should == [:Function, :Style] 

Function().instance_methods.should == [:far]
Style().instance_methods.should == [:pretty]    
</code></pre>

<h4>
<a id="injectorssyms" class="anchor" href="#injectorssyms" aria-hidden="true"><span class="octicon octicon-link"></span></a>#injectors(*syms)</h4>

<p>Called with no arguments returns a list of injector symbols.  A call with a list of injector symbols however returns an array of actual Injector objects. An example use goes like this:</p>

<pre><code>class Target
  inject function
  inject style
end

# later on...
Target.injectors.each{ |ij| Target.eject ij }  
</code></pre>

<h3>
<a id="other-capabilities-of-injectors" class="anchor" href="#other-capabilities-of-injectors" aria-hidden="true"><span class="octicon octicon-link"></span></a>Other Capabilities of Injectors</h3>

<p>The functionality of an injector can be removed from an #enrich to individual objects:</p>

<pre><code>class Coffee
    def cost
        1.00
    end
end
injector :milk do
    def cost
        super() + 0.50
    end
end

cup = Coffee.new.enrich(milk)
friends_cup = Coffee.new.enrich(milk)

cup.cost.should == 1.50
friends_cup.cost.should == 1.50

cup.eject :milk

cup.cost.should == 1.00

# friends cup didn't change price
friends_cup.cost.should == 1.50
</code></pre>

<p>Or, from an #inject at the class level:</p>

<pre><code># create the injection
class Home
    injector :layout do
        def fractal
        end
    end
    inject layout
end
expect{Home.new.fractal}.to_not raise_error

# build
my_home = Home.new
friends = Home.new

# eject the code
class Home
    eject :layout
end

# the result
expect{my_home.fractal}.to raise_error
expect{friends.fractal}.to raise_error
expect{Home.new.fractal}.to raise_error
</code></pre>

<p>The code for this makes use of :eject which is also part of Jackbox and opens the door to some additional functionality provided by injectors.  This additional function allows Injectors to be truly used to inject and eject code at will.</p>

<h4>
<a id="ejectsym" class="anchor" href="#ejectsym" aria-hidden="true"><span class="octicon octicon-link"></span></a>:eject(sym)</h4>

<p>This method ejects injector function from a single object or class.  For other forms of injector withdrawal see the next sections.  It is in scope on any classes injected or enriched by an injector.  With this capability we can do the following with our Spaceship example from above:</p>

<pre><code>SpaceShip.injectors.should == [:FuelSystem, :Engines, :Capsule, :Landing]
flyer.injectors.should == [:FuelSystem, :Engines, :Capsule, :Landing]
flyer.fuel_lines :on
flyer.ignition :on
flyer.o2
flyer.gear.should == 'wheels'

# eject class level injector at the object level
flyer.eject :Capsule

# expect errors
SpaceShip.injectors.should == [:FuelSystem, :Engines, :Capsule, :Landing]
flyer.injectors.should == [:FuelSystem, :Engines, :Landing]
expect{flyer.o2}.to raise_error
flyer.fuel_lines :dead
flyer.ignition :on
flyer.gear.should == 'wheels'
</code></pre>

<p>For more details see the Rspec examples in this project.</p>

<h3>
<a id="the-gof-strategy-pattern" class="anchor" href="#the-gof-strategy-pattern" aria-hidden="true"><span class="octicon octicon-link"></span></a>The GOF Strategy Pattern:</h3>

<p>Another pattern that Jackbox helps with is the GOF Strategy Pattern.  This is a pattern with changes the guts of an object as opposed to just changing its face. Traditional examples of this pattern use PORO component injection within constructors. </p>

<p>Here are a couple alternate implementations:</p>

<pre><code>class Coffee
    attr_reader :strategy

    def initialize
      @strategy = nil
    end
    def cost
        1.00
    end
  def brew
        @strategy = 'normal'
  end
end

cup = Coffee.new
cup.brew
cup.strategy.should == 'normal'


injector :sweedish do
    def brew
        @strategy = 'sweedish'
    end
end

cup = Coffee.new.enrich(sweedish)             # clobbers original strategy for this instance only!!
cup.brew
cup.strategy.should == ('sweedish')
</code></pre>

<p>But, with #eject it is possible to have an even more general alternate implementation. This time we completely replace the current strategy by actually ejecting it out of the class and then injecting a new one:</p>

<pre><code>class Tea &lt; Coffee  # Tea is a type of coffee!! ;~Q)
    injector :SpecialStrategy do
        def brew
            @strategy = 'special'
        end
    end
    inject SpecialStrategy()
end

cup = Tea.new
cup.brew
cup.strategy.should == 'special'

Tea.eject :SpecialStrategy

Tea.inject sweedish

cup.brew
cup.strategy.should == 'sweedish'
</code></pre>

<h3>
<a id="injector-directives" class="anchor" href="#injector-directives" aria-hidden="true"><span class="octicon octicon-link"></span></a>Injector Directives</h3>

<p>Once you have an injector handle you can also use it to issue directives to the injector.  These directives can have a profound effect on your code.</p>

<h4>
<a id="collapse-directive" class="anchor" href="#collapse-directive" aria-hidden="true"><span class="octicon octicon-link"></span></a>:collapse directive</h4>

<p>This description produces similar results to the previous except that further injector method calls DO NOT raise an error.  They just quietly return nil. Here are a couple of different cases:</p>

<p>The case with multiple objects</p>

<pre><code>injector :copiable do
    def object_copy
        'a dubious copy'
    end
end

o1 = Object.new.enrich(copiable)
o2 = Object.new.enrich(copiable)

o1.object_copy.should == 'a dubious copy'
o2.object_copy.should == 'a dubious copy'

copiable :silence

o1.object_copy.should == nil
o2.object_copy.should == nil
</code></pre>

<p>The case with a class receiver:</p>

<pre><code>class SomeClass
    injector :code do
        def tester
            'boo'
        end
    end

    inject code
end

# collapse
SomeClass.code :collapse

# build
a = SomeClass.new
b = SomeClass.new

a.tester.should == nil
b.tester.should == nil

# further
SomeClass.eject :code 
expect{ a.tester }.to raise_error
expect{ b.tester }.to raise_error
</code></pre>

<h4>
<a id="rebuild-directive" class="anchor" href="#rebuild-directive" aria-hidden="true"><span class="octicon octicon-link"></span></a>:rebuild directive</h4>

<p>Injectors that have been collapsed can at a later point then be reconstituted.  Here are a couple of cases:</p>

<p>The case with multiple object receivers:</p>

<pre><code>injector :reenforcer do
    def thick_walls
        '=====  ====='
    end
end

o1 = Object.new.enrich(reenforcer)
o2 = Object.new.enrich(reenforcer)

reenforcer :collapse

o1.thick_walls.should == nil
o2.thick_walls.should == nil

reenforcer :rebuild

o1.thick_walls.should == '=====  ====='
o2.thick_walls.should == '=====  ====='
</code></pre>

<p>The case with a class receiver:</p>

<pre><code>class SomeBloatedObject
    injector :ThinFunction do
        def perform
            'do the deed'
        end
    end
    inject ThinFunction()
end
SomeBloatedObject.ThinFunction :silence

tester = SomeBloatedObject.new
tester.perform.should == nil

SomeBloatedObject.ThinFunction :active
tester.perform.should == 'do the deed'
</code></pre>

<h4>
<a id="implode-directive" class="anchor" href="#implode-directive" aria-hidden="true"><span class="octicon octicon-link"></span></a>:implode directive</h4>

<p>This directive totally destroys the injector including the handle to it.  Use it carefully!</p>

<p>For more information and additional examples see the rspec examples on this project.  There you'll find a long list of rspec example code showcasing some additional features of Jackbox Injectors along with some additional descriptions.</p>

<h2>
<a id="additional-tools" class="anchor" href="#additional-tools" aria-hidden="true"><span class="octicon octicon-link"></span></a>Additional Tools</h2>

<p>Jackbox includes a couple of additional ancillary tools.  The first is an Abstract class base that prevents instantiation of the base class itself but not of its descendants.  The second is a persistent properties module named Prefs; it creates class/module/namespace level persistent properties.</p>

<p>With Abstract the code goes like this:</p>

<pre><code>class Vector
    extend Abstract
    def speed
      0
    end
    def direction
    end
end
expect{Vector.new}.to raise_error

class Velocity &lt; Vector
    def speed
      super + 35
    end
    def direction
      :north
    end
end

expect{Velocity.new}.to_not raise_error
Velocity.new.speed.should == 35
</code></pre>

<p>With Prefs you can add persistent properties to a class.  These properties persist even through program termination. Here is the example code:</p>

<pre><code>module Jester
    extend Prefs

    pref :value =&gt; 10
end

Jester.value.should == 10
Jester.value = 3
Jester.value.should == 3
Jester.reset :value
Jester.value.should == 10 
</code></pre>

<p>There is also command line utility called <strong>jackup</strong> that simply allows users to bring their projects into a <em>"Jackbox level"</em>.  It inserts the right references and turns the targeted project into a bundler gem if it isn't already one also adding a couple of rake tasks.</p>

<h2>
<a id="availability" class="anchor" href="#availability" aria-hidden="true"><span class="octicon octicon-link"></span></a>Availability</h2>

<p>Jackbox is current available for Linux, Mac, and Windows versions of Ruby 1.9.3 thru 2.1.1</p>

<h2>
<a id="installation" class="anchor" href="#installation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Installation</h2>

<p>Add this line to your application's Gemfile:</p>

<pre><code>gem 'jackbox'
</code></pre>

<p>And then execute:</p>

<pre><code>$ bundle
</code></pre>

<p>Or install it yourself as:</p>

<pre><code>$ gem install jackbox
</code></pre>

<p>And then execute the following command inside the project directory:</p>

<pre><code>$jackup 
</code></pre>

<h2>
<a id="support" class="anchor" href="#support" aria-hidden="true"><span class="octicon octicon-link"></span></a>Support</h2>

<p>Any questions/suggestions can be directed to the following email address: </p>

<p><strong><a href="mailto:service.delivered@ymail.com">service.delivered@ymail.com</a></strong>.  </p>

<p>Please include your platform along with a description of the problem and any available stack trace.  Please keep in mind that, at this time we have limited staff and we will do our best to have a quick response time.</p>

<h2>
<a id="licensing" class="anchor" href="#licensing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Licensing</h2>

<p>Jackbox is currently free for anyone to <strong>use</strong>.</p>

<p>THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>

<p>Copyright Â© 2014 LHA. All rights reserved.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Jackbox maintained by <a href="https://github.com/LouHenryAlvarez">LouHenryAlvarez</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-58877141-2");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>


  </body>
</html>
