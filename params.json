{"name":"Jackbox","tagline":"Ruby Modular Closures©, Code Injectors, Re-Classes, and other programmer morphins","body":"<p>Copyright © 2014, 2015 LHA. All rights reserved.</p>\r\n\r\n<p><a href=\"http://jackbox.us\"></a></p><h1><a id=\"user-content-jackbox\" class=\"anchor\" href=\"#jackbox\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a><a href=\"http://jackbox.us\">Jackbox</a></h1><p></p>\r\n\r\n<hr>\r\n\r\n<h2><a id=\"user-content-modular-closures-ruby-traits-code-injectors-class-constructors-and-other-ruby-programmer-morphins\" class=\"anchor\" href=\"#modular-closures-ruby-traits-code-injectors-class-constructors-and-other-ruby-programmer-morphins\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>Modular Closures©, Ruby Traits©, Code Injectors, Class Constructors, and other Ruby programmer morphins</h2>\r\n\r\n<p>The defining thought behind Jackbox is a simple one: If Ruby is like Play-Doh, with Jackbox we want to turn it into <a href=\"https://en.wikipedia.org/wiki/Plasticine\">Plasticine</a>.  The library functionality at this time takes this idea and materializes it in the concepts of traits/injectors, class constructors, the application of versioning to runtimes, and a just-in-time inheritance model that together with the helper functions that bring them together, provide some new and interesting capabilities.  </p>\r\n\r\n<p>To make it easier to grasp, <strong>Ruby Traits</strong> and code injectors can perhaps be thought of as a form of <strong>Modular Closures</strong> which is closures which can also serve as modules.  These modular closures most of all propose some additional properties to the idea of a mix-in.  For instance, they make it possible to solve several general problems in some areas of OOP, overcoming traditional Ruby shortcomings with the GOF Decorator and Strategy Patterns, and enabling <strong>some new code patterns</strong> of our own.  They instrument control over code presence or the presence of trait/injector code in targets with mechanisms involving trait/injector canceling or ejection and also trait directives to for example remain as silent traits and to force the reactivation of traits.  They give your code the ability to capture the surrounding context and mix it into an indiscriminate target. They extend Ruby's mix-in and method resolution over and beyond what is possible with regular modules. </p>\r\n\r\n<p><strong>Class constructors</strong> on the other hand present an alternative way to refine a class.  They provide similar benefits to refinements with a different underpinning. Together with Jackbox code traits and helper functions, class constructors can be refined multiple times.  Capabilities can be added and removed in blocks.  Moreover, these constructors acquire introspecting abilities.  A class constructor can be tested for existence, can tell you what traits it uses, and finally can be overridden with a more relevant one. Constructors also work with Ruby 1.9 and related technologies.</p>\r\n\r\n<p>Following on this we introduce the concept of Trait/Injector Versioning.  This is a feature which allows you to redefine parts of your program in local isolation and without it affecting others.  See Trait/Injector Versioning below. Runtimes can morph their capabilities as they learn about themselves, and they can do so in blocks as granular or as coarse as needed.  These blocks can be updated, ejected, silenced, or re-injected with more function. This versioning also provides a form of inheritance.  We have called this versioned inheritance and it allows newer versions to inherit from previous ones, be tagged and labeled, and this way be capable of reuse.  All this is further enhanced by the ability of Jackbox to resolve methods through the use of the VMC (Virtual Method Cache). See below.</p>\r\n\r\n<p>Finally, we also present the concept of <strong>Just-In-Time Inheritance©</strong>.  This is a feature which allows the production of an ancestor hierarchy similar to what you find in Ruby classes just as it is needed by your code.  With it you can override previous members of a tag and expect to have access to its super members as part of the call, just like you would with classes.  But, this inheritance is all going on in the mix-in --the Modular Closure.  Families of traits can be built with the use of this and the previous versioned inheritance, and unlike class inheritance be readily applicable to any target.</p>\r\n\r\n<p>We have chosen to keep the code obfuscated <strong>for now</strong> because we are a small company with fewer resources and we need to protect our germinating intellectual property.  But, as our business model evolves we will be considering open sourcing it.  We take great pride in providing significant value at minimal cost.  Our guiding principle through out it all has been keeping new constructs to a minimum.  We took an outer minimalistic approach requiring a lot more behind the scenes.  Simplicity takes work.  We hope that all this work is to your liking.</p>\r\n\r\n<h2><a id=\"user-content-advantages-of-trait-based-programming\" class=\"anchor\" href=\"#advantages-of-trait-based-programming\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>Advantages Of Trait Based Programming</h2>\r\n\r\n<ul>\r\n<li>Traits are inherited from their ancestors and can be mixed in with any target.</li>\r\n<li>With Traits you avoid the perils of monkey patching.  You can just create a new version of the trait and leave the old one alone.</li>\r\n<li>Traits can be silenced and reactivated.</li>\r\n<li>With Traits runtime versioning is possible and traits can be upgraded with new versions of the trait.</li>\r\n<li>Traits enable new and different coding patterns.</li>\r\n</ul>\r\n\r\n<hr>\r\n\r\n<h2><a id=\"user-content-basic-methods\" class=\"anchor\" href=\"#basic-methods\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>Basic Methods</h2>\r\n\r\n<p>There are some basic methods to Jackbox.  These are just rudimentary helpers, which in effect appear to be a form of syntax sugar for every day things.  But, behind their apparent sugar coating lie some additional capabilities as shown the deeper you delve into Jackbox.  For more on them read the following sections, but their preliminary descriptions follow here:</p>\r\n\r\n<h4><a id=\"user-content-decorate-sym-blk\" class=\"anchor\" href=\"#decorate-sym-blk\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>#decorate :sym, &amp;blk</h4>\r\n\r\n<p>This method allows for decorations to be placed on a single method whether an instance or class method without too much fuss. One important thing about #decorate is that it works like #define_method, but in addition, it also makes possible the use of Ruby's #super within the body of the decorator.  It really presents a better alternative and can be used instead of #alias_method_chain.</p>\r\n\r\n<p>At the class level:</p>\r\n\r\n<pre><code>class One\r\n  def foo\r\n    'foo'\r\n  end\r\nend\r\n\r\nclass One\r\n  decorate :foo do\r\n    super() + 'decoration '                   # super available within decoration\r\n  end\r\nend\r\n\r\nOne.new.foo.should == 'foo decoration'\r\n</code></pre>\r\n\r\n<p>Or, at the instance level:</p>\r\n\r\n<pre><code>one = One.new\r\n\r\none.decorate :foo do |arg|\r\n  super() + arg                               # again the use of super is possible\r\nend\r\n\r\none.foo('after').should == 'foo decoration after'\r\n</code></pre>\r\n\r\n<p>It also works like so:</p>\r\n\r\n<pre><code>Object.decorate :to_s do\r\n    super() + \" is your object\"\r\nend\r\n\r\nObject.new.to_s.should match(/is your object/)\r\n</code></pre>\r\n\r\n<h4><a id=\"user-content-with-obj-blk\" class=\"anchor\" href=\"#with-obj-blk\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>#with obj, &amp;blk</h4>\r\n\r\n<p>There is also a new version of the #with construct.  The important thing to remember about #with is it has a primary context which is the object passed to it, and a secondary context which is the object you are making the call from.  This allows you to work <strong>with</strong> both contexts at the same time. The other important thing about #with is that it allows you to directly place definitions on and returns the same object you passed into it, or the result of the last evaluation in the #with block on the alternative.</p>\r\n\r\n<p>Here is some sample usage code:</p>\r\n\r\n<pre><code>class One\r\n  def meth1(arg)\r\n    'in One ' + arg\r\n  end\r\nend\r\n\r\nclass Two\r\n  def meth2(arg)\r\n    'and in Two ' + arg\r\n  end\r\n  def meth\r\n    with One.new do                           # context of One and Two available simultaneously!!!\r\n      return meth1 meth2 'with something'         \r\n    end                                       # return object\r\n  end\r\nend\r\n\r\nTwo.new.meth.should == 'in One and in Two with something'\r\n</code></pre>\r\n\r\n<p>Use it to define function:</p>\r\n\r\n<pre><code># internal facade for Marshal\r\nwith Object.new do\r\n\r\n    @file_spec = [file, mode]               \r\n    def dump hash\r\n        File.open(*@file_spec) do |file|\r\n            Marshal.dump( hash, file)\r\n        end\r\n    end\r\n    def load hash\r\n        File.open(*@file_spec) do |file|\r\n            hash.merge!(Marshal.load( file ))\r\n        end\r\n    end\r\n\r\nend\r\n</code></pre>\r\n\r\n<p>Use it with <strong>#decorate</strong> on singleton classes like this:</p>\r\n\r\n<pre><code>class Dir\r\n\r\n  with singleton_class do\r\n    decorate :entries do |name='.', opts=nil| #:doc:\r\n      super name, opts\r\n    end\r\n    decorate :new do |name, &amp;code| #:doc:\r\n      FileUtils.mkpath name unless exists?(name)\r\n      return Dir.open(name, &amp;code) if code\r\n      Dir.open name\r\n    end\r\n  end\r\n\r\nend\r\n</code></pre>\r\n\r\n<h4><a id=\"user-content-lets-symnil-blk\" class=\"anchor\" href=\"#lets-symnil-blk\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>#lets sym=nil, &amp;blk</h4>\r\n\r\n<p>We could say, this is simple syntax sugar.  It adds readability to some constructs, and it allows the creation of local or global procs using a more friendly syntax. But #lets, also opens the door to a new coding pattern using class constructors.  See below.  The important thing about #lets is that it always defines some lambda/proc/method.  It's use differs from that of #define_method only in spirit, aside its use with respect to class constructors, #lets is mostly for one liners.  Here are some examples:</p>\r\n\r\n<p>To define local functions/lambdas. Define symbols in local scope:</p>\r\n\r\n<pre><code>def main\r\n  lets bar =-&gt;(arg){ arg * arg }              # read as: lets set bar to lambda/proc \r\n\r\n  # later on ...\r\n\r\n  var = bar[3]                                # bar is only available within #main\r\n  #...\r\nend                                                         \r\n</code></pre>\r\n\r\n<p>As a shortcut for define_method. Use it for short functional definitions:</p>\r\n\r\n<pre><code>lets( :meth ){ |arg| arg * 2 }                # read as: lets define symbol :meth to be ....\r\nmeth(3)                                                         \r\n# =&gt; 6 \r\n</code></pre>\r\n\r\n<p>Can be used to define a special values or pseudo-immutable strings:</p>\r\n\r\n<pre><code>lets(:foo){ 3+Math::Pi }                      # read as: lets set :foo to value\r\nlets(:faa){ 'some important string' }\r\n</code></pre>\r\n\r\n<h2><a id=\"user-content-traitsinjectors\" class=\"anchor\" href=\"#traitsinjectors\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>Traits/Injectors</h2>\r\n\r\n<p>Traits are the main tool in Jackbox at the time of this writing. These again are a form of mix-in that have properties of both a closure and a module.  They can also be thought of as an <strong>extended closure</strong> if you will or as a special kind of mix-in if you want.  In the sections below we will discuss some of the methods available to you with Jackbox in connection with Traits, as well as elaborate on some of the other properties of traits. But, it is essential to understand there are some syntactical differences to Traits/Injectors with respect to regular modules.  We will show them first, with some examples: </p>\r\n\r\n<p><strong>TRAITS/INJECTORS ARE DECLARED IN THE FOLLOWING WAYS:</strong></p>\r\n\r\n<pre><code>trait :name\r\n\r\n#  or...\r\n\r\nName = trait :name\r\n\r\n# or even ...\r\n\r\ninjector :Name                                    # capitalized method, using alias #trait \r\n</code></pre>\r\n\r\n<p>Their use and semantics are somewhat defined by the following snippet.  But, to fully understand their implications to your code, you have to understand the sections on trait versioning, their behavior under inheritance, and also trait directives. </p>\r\n\r\n<pre><code># somewhere in your code\r\ninclude Traits\r\n\r\ntrait :my_trait                             # define the trait \r\n\r\nmy_trait do                     \r\n  def bar                  \r\n    :a_bar\r\n  end\r\nend\r\n\r\n# later on...\r\nwidget.extend my_trait                      # apply the trait\r\n\r\nwidget.bar\r\n# =&gt; bar\r\n\r\n# or...  \r\n\r\nMine = my_trait\r\nclass Target\r\n  inject Mine                               # apply the trait\r\nend\r\n\r\nTarget.new.bar\r\n# =&gt; bar\r\n</code></pre>\r\n\r\n<p><strong>TRAITS/INJECTORS HAVE PROLONGATIONS:</strong></p>\r\n\r\n<pre><code>trait :my_trait\r\n\r\nmy_trait do                                # first prolongation\r\n\r\n  def another_method\r\n  end\r\n\r\nend\r\n\r\n# ...\r\n\r\nmy_trait do                                # another prolongation\r\n\r\n  def yet_another_method\r\n  end\r\n\r\nend\r\n</code></pre>\r\n\r\n<p>These prolongations become versions once applied or tagged.  See Tagging/Naming below.  In lieu of this they remain in the Virtual Method Cache (see below) in an un-versioned state available to any client.  </p>\r\n\r\n<h4><a id=\"user-content-traitinjector-sym\" class=\"anchor\" href=\"#traitinjector-sym\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>#trait/#injector :sym</h4>\r\n\r\n<p>This is a global function.  It defines an object of type Trait/Injector with the name of :symbol.  Use it when you want to generate an Trait/Injector object for later use.  The symbol can then be used as a handle to the trait whenever you need to prolong the trait by adding methods to it, or to apply it to a target generating a version.  Additionally, this symbol plays a role in defining the trait's scope.  Traits/Injectors with capitalized names like :Function, :Style, etc have a global scope.  That is, they are available throughout the program, regardless of where they are defined.  Here is the code:</p>\r\n\r\n<pre><code>class A\r\n  trait :Function                         # defined\r\nend\r\n\r\nclass B\r\n  include Function()                      # applied\r\nend\r\n\r\n# This is perfectly valid with traits  \r\n</code></pre>\r\n\r\n<p>On the other hand Traits/Injectors with a lower case name are only available <strong>from</strong> the scope in which they were defined, like the following example shows:</p>\r\n\r\n<pre><code>class A\r\n  trait :form\r\nend\r\n\r\nclass B\r\n  include form                                # This genenerates and ERROR!                                 \r\nend                         \r\n\r\nclass B\r\n  include A.form                              # This is valid however!\r\nend\r\n</code></pre>\r\n\r\n<p>For all this to happen Jackbox also introduces some additional Ruby constructs, namely the keywords #inject and #enrich.  These can be thought as simply new corollaries to #include and #extend. In fact they can be used interchangeably.  If you're working with traits you may want to use them instead, depending on context, to make clear your intent.  Also #inject is public on classes (not on other traits) while #include is not.</p>\r\n\r\n<h4><a id=\"user-content-includeinject-t\" class=\"anchor\" href=\"#includeinject-t\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>#include/inject *t</h4>\r\n\r\n<p>This method is analogous to ruby's #include but its use is reserved for Trait Injectors.  The scope of this method is the same as the scope of #include, and its intended use like that of #include is for class definitions. Use it to \"include\" a trait into a receiving class.  Also takes multiple traits.</p>\r\n\r\n<h4><a id=\"user-content-extendenrich-t\" class=\"anchor\" href=\"#extendenrich-t\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>#extend/enrich *t</h4>\r\n\r\n<p>This method in turn is analogous to ruby's #extend. The scope of this method is also the same as that of #extend, and its intended use if for object definition.  Use it to \"extend\" the receiver of a trait.  Also takes multiple traits.</p>\r\n\r\n<p><strong>IMPORTANT NOTE: Trait Injector lookup follows the method and not the constant lookup algorithm.</strong></p>\r\n\r\n<p>If you need to follow constant lookup, here is the code for that:</p>\r\n\r\n<pre><code>Name = trait :sym ....                     # this also creates a hard tag (see below)\r\n</code></pre>\r\n\r\n<h3><a id=\"user-content-traitinjector-versioning\" class=\"anchor\" href=\"#traitinjector-versioning\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>Trait/Injector Versioning</h3>\r\n\r\n<p>One of the most valuable properties of Jackbox is Trait Injector Versioning.  Versioning is the term used to identify a feature in the code that produces an artifact which contains a certain set of methods and associated outputs, and which represents a snapshot of that trait up until the point it's applied to an object.  From, that point on the object contains only that version of trait methods, and any subsequent overrides to those methods on the trait are only members of the \"prolongation\" of that trait and do not become part of previous targets unless some form of trait re-injection occurs. Newer versions of a trait only become part of newer targets or newer trait injections into existing targets.  With Jackbox Trait/Injector Versioning, two different versions of the same code object can be running simultaneously. </p>\r\n\r\n<p>We'll use some examples to illustrate the point.  This is how versioning occurs:</p>\r\n\r\n<pre><code># trait declaration\r\n#___________________\r\ntrait :my_trait do                                                          \r\n  def bar\r\n    :a_bar                                  # version bar.1\r\n  end\r\n  def foo\r\n    # ...\r\n  end\r\nend\r\n\r\nobject1.extend my_trait                     # apply the trait --first snapshot\r\nobject1.bar.should == :a_bar                # pass the test\r\n\r\n# trait prolongation\r\n#__________________\r\nmy_trait do                                                                             \r\n  def bar\r\n    :some_larger_bar                        # version bar.2 ... re-defines bar\r\n  end\r\n  # ...\r\nend\r\n\r\nobject2.extend my_trait                     # apply the trait --second snapshot\r\nobject2.bar.should == :some_larger_bar      # pass the test\r\n\r\n###############################################\r\n# First object has kept its preferred version #\r\n###############################################\r\n\r\nobject1.bar.should == :a_bar                # bar.1 is still the one\r\n</code></pre>\r\n\r\n<p>When trait re-injection occurs, and only then does the new version of the #bar method come into play. But the object remains unaffected otherwise, keeping its preferred version of methods.  The new version is available for further injections down the line and to newer client code but existing targets are untouched.  Internal local-binding is also preserved.  If a trait is then re-injected on an instance only then does the instance get updated with the newer version.  Here is the code:</p>\r\n\r\n<pre><code># re-injection\r\n#_________________\r\nobject1.extend my_trait                     # re-injection --third snapshot\r\n\r\n###############################################\r\n# First object now has the updated version    #\r\n###############################################\r\n\r\nobject1.bar.should == :some_larger_bar      # bar.2 now available\r\n</code></pre>\r\n\r\n<p>Re-injection on classes is a little bit trickier, because class injection is more pervasive.  To re-inject a class with a trait we must use the Strategy Pattern (see below) or use private #update's.  See the sections below as well as the rspec files for more on this.   </p>\r\n\r\n<p>Here is an example of Injector Versioning as it pertains to classes:</p>\r\n\r\n<pre><code># trait declaration:\r\n#___________________\r\ntrait :Versions do\r\n  def meth arg                                # version meth.1\r\n    arg ** arg\r\n  end\r\nend\r\n\r\nclass One\r\n  inject Versions()                           # apply --snapshot\r\nend\r\n\r\n# trait extension:                              \r\n#_________________\r\nVersions do\r\n  def meth arg1, arg2                         # version meth.2 ... redefines meth.1\r\n    arg1 * arg2\r\n  end\r\nend\r\n\r\nclass Two\r\n  inject Versions()                           # apply --snapshot\r\nend\r\n\r\n##############################################\r\n# Two different trait versions coexisting    #\r\n##############################################\r\n\r\nOne.new.meth(3).should == 27                  # meth.1\r\nTwo.new.meth(2,4).should == 8                 # meth.2 \r\n</code></pre>\r\n\r\n<p>To update the class, we then do the following:</p>\r\n\r\n<pre><code>class One\r\n  update Versions()                           # private call to #update\r\nend\r\n\r\n##############################################\r\n# class One is now updated to the latest     #\r\n##############################################\r\n\r\nOne.new.meth(2,4).should == 8                 # meth.2 \r\nTwo.new.meth(2,4).should == 8                 # meth.2 \r\n</code></pre>\r\n\r\n<h3><a id=\"user-content-taggingnaming\" class=\"anchor\" href=\"#taggingnaming\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>Tagging/Naming</h3>\r\n\r\n<p>The use of Tags is central to the concept of Versioning.  Tagging happens in the following ways:</p>\r\n\r\n<pre><code>Version1 = trait :function do\r\n  def meth arg\r\n    arg\r\n  end\r\n  def mith\r\n    meth 2\r\n  end\r\nend\r\n\r\nVersion2 = function do\r\n  def mith arg\r\n    meth(arg) * meth(arg)\r\n  end\r\nend\r\n</code></pre>\r\n\r\n<p>Version1 and Version2 are two different hard tags of the same Trait Injector.  They introduce a more formal approach to trait versioning and also pave the way for the inheritance models described in the introduction.  Aside from hard tags, there are also soft tags (see below).  </p>\r\n\r\n<h3><a id=\"user-content-local-binding\" class=\"anchor\" href=\"#local-binding\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>Local Binding</h3>\r\n\r\n<p>Before we move on, we also want to give some further treatment to trait local-binding.  That is, the binding of a traits' methods is local to the prolongation/version in which they are located before the versioning occurs.  Here, is the code:</p>\r\n\r\n<p><strong>Note: In the following examples we use the notion of version naming/tagging.  Once a version is tagged it shouldn't be modified.  These tags comprise entities along the hierarchical structure of a trait.</strong></p>\r\n\r\n<pre><code># trait declaration\r\n#_____________________\r\n\r\nVersion1 = trait :functionality do\r\n  def basic arg                               # version basic.1\r\n    arg * 2\r\n  end\r\nend\r\no = Object.new.extend Version1                # apply --snapshot (like above)\r\n\r\n\r\n# trait prolongation\r\n#_____________________\r\n\r\nVersion2 = functionality do\r\n  def basic arg                               # version basic.2\r\n    arg * 3                                   # specific use in compound.1\r\n  end\r\n\r\n  def compound                                # compound.1 \r\n    basic(3) + 2                                      \r\n  end\r\nend\r\np = Object.new.extend Version2                # apply --snapshot (like above)\r\n\r\n####################################################\r\n# #compound.1 bound to the right version #basic.2  #\r\n####################################################\r\n\r\np.basic(1).should == 3                        # basic.2 \r\np.compound.should == 11                       # compound.1 --bound locally to basic.2\r\n\r\no.basic(1).should == 2                        # basic.1 \r\no.compound.should == 11                       # compound.1 --bound locally to basic.2\r\n</code></pre>\r\n\r\n<h3><a id=\"user-content-virtual-method-cache-vmc\" class=\"anchor\" href=\"#virtual-method-cache-vmc\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>Virtual Method Cache (VMC)</h3>\r\n\r\n<p>When you are working with a trait injector in irb/pry it is often easier to just add methods to the trait without actually having to re-apply the trait to the the target to see the result.  This is just what the Virtual Method Cache is for <strong>among other things.</strong>  The VMC allows working with traits like you would with regular modules.  It also enhances the normal method resolution of modules into that of modules in the chain but not directly applied to the target.  Here is what the code looks like:</p>\r\n\r\n<pre><code># definition\r\n#_______________\r\ntrait :SomeTrait\r\n\r\n# application\r\n#_______________\r\nclass MyClass\r\n  include SomeTrait                           # Application (with no methods)\r\nend\r\n\r\nobj = MyClass.new\r\n\r\nSomeMethods do\r\n  def spm1                                    # #spm1 is only defined in the virtual cache\r\n    :result                                   # It is not actually part of the class yet!!\r\n  end                                         # until this version/prolongation is applied\r\nend\r\n\r\nexpect(obj.spm1).to eq(:result)               # yet my obj can use it --no problem\r\n</code></pre>\r\n\r\n<p>The key idea here is that the virtual method cache is the same for all versions of the Injector and all its applications.  This is what allows working with traits as if they were regular modules.  If we redefine VMC methods they are also redefined for all versions.  To actually lock the method versions into place you must apply the Injector with the methods defined in it that you want the version to have.  To then change that application of the trait you then re-inject the target.  But the VMC, provides a scratch pad of methods for you to work with.  The VMC also provides extended method resolution to the trait.  To understand what we mean by this, take a look at following code:</p>\r\n\r\n<pre><code>class Client\r\n  include trait :J1\r\nend\r\nJ1 do\r\n    def n1m1\r\n    end\r\n  include trait :K1\r\nend\r\nK1 do\r\n    def n2m1\r\n    end\r\n  include trait :L1\r\nend\r\nL1 do\r\n  def n3m1\r\n  end\r\nend\r\n\r\nClient.new.n1m1\r\nClient.new.n2m1\r\nClient.new.n3m1\r\n</code></pre>\r\n\r\n<p>Think of how this would be different with regular modules.  For this to happen using regular Ruby modules K1 and L1 should have to be defined and included prior to their inclusion into our client.  And no it is not just a matter of moving the include to the beginning of each container.</p>\r\n\r\n<h4><a id=\"user-content-define_method-sym-blk\" class=\"anchor\" href=\"#define_method-sym-blk\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>#define_method sym, &amp;blk</h4>\r\n\r\n<p>There is one more interesting property to method definition with Trait Injectors however. The use of #define_method to define/re-define methods in any prolongation affects the entire trait and all its versions.  This also preserves a fundamental tenet of traits: take some local context, enclose it, and use the trait to introduce it to some indiscriminate target, and additionally has some other uses as we'll see with in our description of patterns and trait composition.  </p>\r\n\r\n<p>Here is an example of the difference with #define_method:</p>\r\n\r\n<pre><code># define trait\r\n#_________________________\r\ntrait :some_trait do\r\n    def meth\r\n      :meth\r\n    end\r\n\r\n    def foo_bar\r\n        'a foo and a bar'\r\n    end\r\nend\r\n\r\nclass Client                                  \r\n  inject some_trait                           # Injector appplied\r\nend                                           \r\n\r\n# test it\r\n\r\nClient.new.meth.should == :meth\r\nClient.new.foo_bar.should == 'a foo and a bar'      \r\n\r\n# new prolongation\r\n#________________________\r\nsome_trait do                                  \r\n    def meth                                    \r\n      puts :them\r\n    end\r\n\r\n    define_method :foo_bar do                   # new method version\r\n        'fooooo and barrrrr'\r\n    end\r\nend     \r\n\r\n################################\r\n# Like above!                  #\r\n# No re-injection == No change #\r\n################################\r\n\r\nClient.new.meth.should == :meth \r\n\r\n################################\r\n# Different!!!                 #\r\n# No re-injection == Change    #\r\n# . Thanks to define_method    #\r\n################################\r\n\r\nClient.new.foo_bar.should == 'fooooo and barrrrr'                          \r\n</code></pre>\r\n\r\n<p>Versioning together with local-binding allow the metamorphosis of traits to fit the particular purpose at hand, keeping those local modifications isolated from the rest of your program, and allowing your code to naturally evolve with your program.  They cancel the need to monkey patch anything.  If you need a local version of some code just open up a prolongation create the new version, inject it in to your targets, and leave the older versions and clients untouched.</p>\r\n\r\n<h3><a id=\"user-content-traitinjector-introspection\" class=\"anchor\" href=\"#traitinjector-introspection\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>Trait/Injector introspection</h3>\r\n\r\n<p>Trait Injectors have the ability to speak about themselves.  Moreover traits can speak about their members just like any module or class, and can also inject their receivers with introspecting capabilities.  Every injected/enriched object or module/class can enumerate its traits, and traits can enumerate their members, and so forth.  </p>\r\n\r\n<pre><code>trait :Function do\r\n  def far\r\n  end\r\n  def close\r\n  end\r\nend\r\n\r\ntrait :Style do\r\n    def pretty\r\n    end\r\nend\r\n\r\nclass Parent\r\n  inject Function()\r\nend\r\n\r\nclass Child &lt; Parent\r\n  inject Style()\r\nend\r\n\r\n# a trait's class\r\n\r\nFunction().class.should == Injector                 \r\nStyle().class.should == Injector \r\n\r\nInjector == Trait\r\n\r\n# traits methods\r\n\r\nFunction().instance_methods.should == [:far, :close]      \r\nStyle().instance_methods.should == [:pretty]    \r\n\r\n# later on...\r\n\r\nChild.eject *Child.traits       \r\n</code></pre>\r\n\r\n<h4><a id=\"user-content-traits-sym\" class=\"anchor\" href=\"#traits-sym\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>#traits *sym</h4>\r\n\r\n<p>Called with no arguments returns a list of traits.  A call with a list of trait symbols however returns an array of actual Trait Injector objects matching the names supplied in a LIFO fashion. The method also extends into a sub-mini API.  An example use goes like this:</p>\r\n\r\n<pre><code>#traits   --(in this target)\r\n\r\n  Child.traits \r\n  =&gt; [(|Style|:#942460)] \r\n\r\n#traits :all   --(all traits in hierarchy)\r\n\r\n  Child.traits :all\r\n  =&gt; [(|Function|:#944120), (|Style|:#942460)] \r\n\r\n#traits *sym\r\n\r\n  c = Child.new.extend Style()\r\n  c.traits :Style\r\n  =&gt; [(|Style|:#942460), (|Style|:#890234)] \r\n\r\n\r\n#traits.by\\_name *sym  --(names only)\r\n\r\n  Child.traits.by_name.should == [:Style] \r\n  Child.traits(:all).by_name.should == [:Function, :Style]\r\n  # also aliased to :sym_list\r\n\r\n#traits.collect\\_by\\_name *sym  --(all #traits of :name, same as #traits *sym  from above)\r\n\r\n  Child.traits.collect_by_name :Style\r\n   =&gt; [(|Style|:#942460)]\r\n\r\n  Child.traits :Style\r\n   =&gt; [(|Style|:#942460)]\r\n\r\n  Child.traits :Function\r\n   =&gt; nil\r\n\r\n  Child.traits :all, :Function\r\n   =&gt; [(|Function|:#944120)]                    \r\n\r\n  Child.traits(:all).collect_by_name :Function\r\n   =&gt; [(|Function|:#944120)]                    \r\n  # also aliased to :all_by_sym\r\n\r\n#traits.find\\_by\\_name *sym  --(highest ranking trait by :name)\r\n\r\n  Child.traits.find_by_name :Style       # last one in first out\r\n  =&gt; (|Style|:#942460)\r\n\r\n  Child.traits.find_by_name :Function\r\n   =&gt;nil\r\n\r\n  Child.traits(:all).find_by_name :Function\r\n   =&gt; (|Function|:#944120)                    \r\n  # aliased to last_by_sym\r\n</code></pre>\r\n\r\n<h4><a id=\"user-content-history-alias-versions\" class=\"anchor\" href=\"#history-alias-versions\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>#history alias #versions</h4>\r\n\r\n<p>This method returns a trace of all the hosted Trait Injectors which is ordered based on the order in which they are created.  It also includes the pseudo-hosted hard tags and soft tags which can also be specifically accessed through the #tags method below.  It is primarily a view of all existing versions of a trait. Here is the code:</p>\r\n\r\n<pre><code># create our trait and\r\n# host it a couple of times\r\n\r\ntrait :HistorySample\r\nextend HistorySample(), HistorySample()\r\n\r\n# expect the following\r\n\r\nexpect(HistorySample().history.size).to eq(2)\r\nexpect(traits).to eq(HistorySample().history)\r\nexpect(HistorySample().history.last).to eql(traits.last)\r\nexpect(HistorySample().history.last).to eql(HistorySample())\r\n\r\n# create a hard tag\r\n\r\nHistorySampleTag = HistorySample()\r\n\r\nexpect(HistorySample().history.size).to eq(3)\r\nexpect(HistorySample().history.last).to equal(HistorySampleTag)\r\n\r\n# create a soft tags\r\n\r\nHistorySample(:tag) do\r\n  # some definitions\r\nend\r\n\r\nexpect(HistorySample().history.size).to eq(4)\r\nexpect(HistorySample().history.last).to equal(HistorySample())\r\n</code></pre>\r\n\r\n<h4><a id=\"user-content-tags\" class=\"anchor\" href=\"#tags\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>#tags</h4>\r\n\r\n<p>This method traces the tags only.  The method also extends into a sub-mini API returning hard and soft tags independently. Here is the code:</p>\r\n\r\n<pre><code># at this point from the above...\r\n\r\n#tags\r\n\r\n  expect(HistorySample().tags.size).to eq(3)\r\n\r\n#tags.hard\r\n\r\n  expect(HistorySample().tags.hard.size).to eq(1) \r\n  HistorySample().tags.hard\r\n   =&gt; [(HistorySampleTag:|HistorySample|)]\r\n\r\n#tags.soft\r\n\r\n  expect(HistorySample().tags.soft.size).to eq(2) \r\n  HistorySample().tags.hard\r\n  =&gt; [(|HistorySample|:#234435),(|HistorySample|:#876679)]\r\n</code></pre>\r\n\r\n<p>The reason for hard tags is related to inheritance while that of soft tags is connected to composition.  For more on this take a look at the Solutions Pattern below for an application of soft tags and at JITI for hard tags and its connection to inheritance.  See also the Jackbox blog at <a href=\"http://jackbox.us\"></a><a href=\"http://jackbox.us\">http://jackbox.us</a> and the rspec files for the project.</p>\r\n\r\n<h4><a id=\"user-content-precedent-and-progenitor-alias-pre-pro\" class=\"anchor\" href=\"#precedent-and-progenitor-alias-pre-pro\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>#precedent and #progenitor (alias #pre, #pro)</h4>\r\n\r\n<p>The #pre method gets the previous element in the history. Here is the code:</p>\r\n\r\n<pre><code># create the trait\r\ntrait :HistorySample\r\n\r\n# create some history\r\nextend HistorySample(), HistorySample()\r\n\r\n# expect the following\r\nexpect(HistorySample().history.last.precedent).to equal(HistorySample().history.first)\r\n</code></pre>\r\n\r\n<p>The #pro method gets the version from which a particular trait was generated. This may not necessarily be the precedent.  Take a look at the following code.</p>\r\n\r\n<pre><code># create the trait\r\ntrait :Progample\r\n\r\n# expect the following\r\nexpect(Progample().history).to be_empty\r\nexpect(Progample().precedent).to equal(Progample().spec)\r\nexpect(Progample().progenitor).to equal(Progample().spec)\r\n\r\n# create some history\r\nextend Progample(), Progample()       \r\n\r\n# expect the following\r\nexpect(Progample().history.size).to eq(2)\r\nexpect(Progample().history.first.progenitor).to equal(Progample().spec)\r\nexpect(Progample().history.last.pro).to equal(Progample().spec)\r\nexpect(Progample().history.last.pre).to equal(Progample().history.first)\r\nexpect(Progample().history.first).to_not equal(Progample().spec)\r\n</code></pre>\r\n\r\n<p>Furthermore:</p>\r\n\r\n<pre><code>Tag = Progample()\r\nexpect(Tag.pro).to equal(Progample().spec)\r\n\r\nclass A\r\n  inject Tag\r\nend\r\n\r\nexpect(A.traits.first.pro).to equal(Tag)\r\n</code></pre>\r\n\r\n<p>For more on this see the rspec files.     </p>\r\n\r\n<h3><a id=\"user-content-traitinjector-equality-and-difference\" class=\"anchor\" href=\"#traitinjector-equality-and-difference\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>Trait/Injector Equality and Difference</h3>\r\n\r\n<p>Injectors can be compared.  This allows further introspection capabilities which can be used to determine if a certain piece of code possesses a certain block of capabilities, test if those are equal to some other component's capabilities, or determine what the difference is.  This is similar to what you would find with simple modules, but capabilities are compared on a method basis.  It only follows that if traits can be applied and withdrawn from any target we should be able to test for their similarities to other traits.  Injector difference on the complement, finds the actual delta between traits and returns and array with those differences.  </p>\r\n\r\n<p>Here is how equality is defined:</p>\r\n\r\n<pre><code># equality\r\n######################################\r\n\r\n    E().should == E()\r\n    E().should == E().spec\r\n    E().should == E().pre\r\n\r\n    # if\r\n    ETag1 = E()                                         # with no definitions\r\n    # then\r\n    E().should == ETag1                         # same thing\r\n\r\n    # if\r\n    extend E()                                          # with no definitions\r\n    # then\r\n    injectors.first.should == E()       # same\r\n\r\n    # but\r\n    E().should == E()                           # always\r\n    E().should == E().spec                  \r\n    E(:tag).should == E()   \r\n</code></pre>\r\n\r\n<p>Inequality is based on a trait's methods.  Once you add method definitions to a trait, that trait tests as inequality to it precedent or progenitor provided this is not the original trait.  The original trait is the #pre and #pro to all others. It always tests as equal to its handle, but versions past or since do not.  A different trait with the same methods is also not equal to the trait.</p>\r\n\r\n<p>Here is how inequality is defined:</p>\r\n\r\n<pre><code># inequality\r\n######################################\r\n\r\n    E().should_not == F()\r\n\r\n# if some E () definitions **\r\nE() do\r\n    def foo                   \r\n    end\r\nend     \r\n\r\n# then (from above)\r\nETag1.should_not == E()         \r\n\r\n# furthermore\r\ntraits.first.should_not == E()\r\n\r\n# and\r\nE().should_not == E().pre\r\n\r\n    # but\r\nE().should == E()                               # always\r\n    E().should == E().spec\r\n</code></pre>\r\n\r\n<p>Difference is deeper than simple inequality.  It returns the actual delta between what you have and what you pass in to the call as an array of two elements.  The first element is the methods common to both operands, the second is the delta from the first to the second.  The method also extends into a sub-mini API.  Furthermore, the elements of the array which are arrays themselves also return a partial trait from their payload which can be used in further trait injection.  Here is how difference is defined:</p>\r\n\r\n<h4><a id=\"user-content-traitdiff-vernil\" class=\"anchor\" href=\"#traitdiff-vernil\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>#trait.diff ver=nil</h4>\r\n\r\n<pre><code># difference\r\n##################################\r\n\r\n#diff(ver=nil)  --( The argument ver=nil defaults to the previous version )\r\n\r\n  E().diff.class.should be(Array)\r\n\r\n\r\n#diff.empty?  --( Is the delta empty? The join could still exist (see below). )\r\n\r\n  E().diff.should be_empty\r\n\r\n\r\n  # because\r\n  E().diff.delta.should be_empty\r\n  E().diff.join.should be_empty\r\n\r\n\r\n  # a tag to compare\r\n  ETag3 = E()\r\n\r\n\r\n  # if some E() definitions **\r\n  E do\r\n    def foo                                     \r\n    end\r\n  end\r\n\r\n\r\n  # E is changed so...\r\n  E().diff(ETag3).should_not be_empty\r\n\r\n\r\n  # because (like above)\r\n  ETag3.should_not == E() \r\n\r\n  # and\r\n\r\n\r\n#diff.delta  --( The difference in methods )\r\n\r\n  E().diff(ETag3).delta.should == [:foo]\r\n\r\n\r\n#diff.loaded? --( Is there both a join and a delta? )\r\n\r\n  E().diff(ETag3).should_not be_loaded\r\n\r\n  # because\r\n\r\n\r\n#diff.join  --( The methods common to both )\r\n\r\n  E().diff(ETag3).join.should == []\r\n\r\n\r\n  # even though\r\n  E().diff(ETag3).delta.should == [:foo]\r\n\r\n\r\n  # furthermore\r\n  E().diff.should == [[], [:foo]] \r\n\r\n\r\n  # being that\r\n  E().diff.should eq( E().diff(E().precedent) )\r\n  # and\r\n  E().progenitor.should equal(E().spec)\r\n\r\n\r\n#diff.join.injector\r\n#diff.delta.injector\r\n\r\n    # a tag as precedent\r\n    ETag5 = E()\r\n\r\n\r\n    # if E() definitions **\r\n    E do\r\n        def foo\r\n            :foo\r\n        end\r\n        def bar\r\n            :bar\r\n        end\r\n    end\r\n\r\n\r\n    # then \r\n    E().diff.should_not be_empty\r\n\r\n    # being that\r\n    E().diff.join.should be_empty\r\n    E().diff.delta.should_not be_empty\r\n    # as for\r\n    E().diff.delta.injector.instance_methods.should == [:foo, :bar]\r\n    # and\r\n    E().diff.delta.injector.should_not eq(E().diff.join.injector)\r\n\r\n    # being that\r\n    E().diff.join.injector.instance_methods.should be_empty\r\n    E().diff.delta.injector.instance_methods.should_not be_empty\r\n\r\n    # allows the following\r\n    class Incomplete\r\n        inject E().diff.delta.injector\r\n    end\r\n    # and\r\n    Incomplete.new.foo.should eq(:foo)\r\n\r\n    # being that\r\n    E().diff.delta.injector.should be_instance_of(Injector)\r\n    E().diff.delta.injector.should be_instance_of(Trait)\r\n</code></pre>\r\n\r\n<p>The version argument can have the following forms: negative index (-1, etc), or another version.  By default, it uses the previous version.  NOTE: the previous version of an un-altered trait is equal to the trait.</p>\r\n\r\n<p>Again, for more on this see the rspec files.</p>\r\n\r\n<h3><a id=\"user-content-traitinjector-composition\" class=\"anchor\" href=\"#traitinjector-composition\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>Trait/Injector composition</h3>\r\n\r\n<p>The composition of multiple traits into an object can be specified as follows:</p>\r\n\r\n<pre><code>include Injectors\r\n\r\n# declare traits\r\ntrait :FuelSystem                          # capitalized methods\r\ntrait :Engines\r\ntrait :Capsule\r\ntrait :Landing\r\n\r\n# compose the object\r\nclass SpaceShip\r\n\r\n    inject FuelSystem(), Engines(), Capsule(), Langing()    # capitalized method use\r\n\r\n    def launch\r\n        gas_tank fuel_lines burners ignition :go              # call through the VMC\r\n        self\r\n    end\r\nend\r\n\r\nSpaceship.traits.by_name == [:FuelSystem, :Engines, :Capsule, :Landing]\r\n\r\n# define functionality\r\nFuelSystem do\r\n    def gas_tank arg\r\n        :gas\r\n    end\r\n    def fuel_lines arg\r\n        :fuel\r\n    end\r\n    def burners arg\r\n        :metal\r\n    end\r\nend\r\n\r\n# ...\r\n\r\n# create object\r\nflyer = SpaceShip.new.launch\r\n\r\n\r\n# in-flight definitions, ha ha ha\r\nvar = 'wheels'\r\n\r\nLanding do\r\n    define_method :gear do                      # a closure of surrounding context\r\n        var\r\n    end\r\nend\r\n</code></pre>\r\n\r\n<p>One thing to note is the difference between defining function through the VMC, which allows working with traits already applied to targets and predefining function of a trait before application and versioning.  The first allows a flow similar to that of regular modules and the later makes use of the true nature of traits and allows customizing traits to their targets.l</p>\r\n\r\n<h3><a id=\"user-content-inheritance\" class=\"anchor\" href=\"#inheritance\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>Inheritance</h3>\r\n\r\n<p>Inheritance with traits comes in two forms.  The first form comes from the normal versioning of a trait.  The second comes from JITI which follows a model similar to what you find in regular classes.  With versioning a trait inherits all the function from its progenitor allowing customization of only the parts needed for the application at hand but cannot call upon previous versions of itself.  With JITI this later dimension of access to its ancestry is possible but we must be aware of colluding ancestry when creating decorators.  Jackbox itself warns you of this however.</p>\r\n\r\n<p>But before this, the behavior of Trait Injectors under normal class inheritance is also of interest.  Trait injectors act upon a class and its children.  Introspection on traits under class inheritance is achieved with the use of the :all directive on the #trait/#injectors method.  This behavior is partially specified by what follows:</p>\r\n\r\n<pre><code>trait :j\r\n\r\nclass C\r\nend\r\n\r\nC.inject j {                                  #foo pre-defined at time of injection\r\n  def foo\r\n    'foo'\r\n  end\r\n}\r\nC.traits.by_name.should == [:j]\r\nC.new.traits.by_name.should == [:j]\r\n\r\nC.new.foo.should == 'foo'\r\n\r\n# D inherits from C\r\n\r\nclass D &lt; C                                   # methods are inherited from j \r\nend\r\nD.traits.by_name.should == []\r\nD.traits(:all).by_name == [:j]\r\n\r\n# New Objects\r\nC.new.foo.should == 'foo'                                           \r\nD.new.foo.should == 'foo'\r\n</code></pre>\r\n\r\n<p>For mote on this as also see the rspec files.</p>\r\n\r\n<p>More importantly though is the following example of trait inheritance due to versioning.  As previously stated, the concept of tag/naming also plays an important role with inheritance, as illustrated in the following code:</p>\r\n\r\n<pre><code>trait :player do                       \r\n    def sound                               \r\n        'Lets make some music'                \r\n    end                                     \r\nend                                       \r\n\r\nTapePlayer = player do                        # TapePlayer version tag\r\n    def play                                    # --inherirts #sound\r\n        return 'Tape playing...' + sound()                          \r\n    end                                     \r\nend                                       \r\n\r\nCDPlayer = player do                          # CDPlayer version tag\r\n    def play                                    # --also inherits #sound\r\n        return 'CD playing...' + sound()\r\n    end\r\nend\r\n\r\nclass BoomBox\r\n    include TapePlayer\r\n\r\n    def on\r\n        play\r\n    end\r\nend\r\n\r\nclass JukeBox &lt; BoomBox\r\n    inject CDPlayer\r\nend\r\n</code></pre>\r\n\r\n<p>The different versions inherit all of the pre-existing methods from the current trait and freeze that function.  We can either Tag/Name it of simply include/extend into a target but the function is frozen at that time.  Tags cannot be modified or more clearly shouldn't be modified.  Classes retain the frozen version of the trait until the time an update is made.  Of course, there is always #define_method and the VMC.   For more on all this see, the Rspec examples.</p>\r\n\r\n<h3><a id=\"user-content-just-in-time-inheritance-jiti\" class=\"anchor\" href=\"#just-in-time-inheritance-jiti\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>Just-In-Time Inheritance (JITI)</h3>\r\n\r\n<p>This flavor of the inheritance model allows our modular closures to have similar properties to the inheritance of classes.  With it you can expect to have access to the trait's super/ancestor members as part of the call, just like you would with classes. In addition to the inheritance resulting from versioning, JITI presents a more complete scenario adding color to the inheritance picture painted by trait injectors.  The key takeaway here is that traits are a form of mix-in that share an enhanced but similar inheritance model with classes. You can version them to gain access to versioned inheritance or you can tag and then override its members to access an ancestor chain comprised of all previous tags.  As always we will use some example code to illustrate:</p>\r\n\r\n<pre><code># \r\n# Our Trait\r\n# \r\nTag1 = trait :Functionality do\r\n    def m1\r\n        1\r\n    end\r\n\r\n    def m2\r\n        :m2\r\n    end\r\nend\r\n\r\n# \r\n# Normal versioned inheritance\r\n# \r\nFunctionality do\r\n    def other                   \r\n        'other'                     # -- same ancestors as before\r\n    end                                 \r\nend\r\n\r\nexpect(Functionality().ancestors).to eql( [Functionality()] )\r\n\r\n# test it\r\n\r\no  = Object.new.extend(Functionality())\r\n\r\n# inherited\r\no.m1.should == 1\r\no.m2.should == :m2\r\n\r\n# current\r\no.other.should == 'other'\r\n\r\n\r\n#\r\n# JITI\r\n# \r\nTag2 = Functionality do\r\n    def m1                          # The :m1 override invokes JIT Inheritance\r\n        super + 1                   # -- Tag1 is summoned into ancestor chain\r\n    end                                 # -- allows the use of super\r\n\r\n    def m3                          \r\n        'em3'\r\n    end\r\nend\r\n\r\n# test it\r\n\r\np = Object.new.extend(Tag2)\r\n\r\n# JIT inherited\r\np.m1.should == 2\r\n\r\n# regular inheritance\r\np.m2.should == :m2\r\np.m3.should == 'em3'\r\np.other.should == 'other'\r\n\r\nexpect(Functionality().ancestors).to eql( [Functionality(), Tag1] )\r\nexpect(Tag2.ancestors).to eql( [Tag2, Tag1] )\r\n</code></pre>\r\n\r\n<h3><a id=\"user-content-the-rules-of-jiti\" class=\"anchor\" href=\"#the-rules-of-jiti\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>The Rules of JITI</h3>\r\n\r\n<p>JITI (Just-In-Time Inheritance) is governed by a set of rules framing its behavior.  Here are these rules and their descriptions:</p>\r\n\r\n<ol>\r\n<li>JITI works like class inheritance but as a mix-in.  It holds onto method definitions of earlier version hard tags.  It lets you override or rebase (start fresh) individual methods at any level.  It works under object extension.  It works under class inclusion.<br></li>\r\n<li>The trait handle is always in sync with the last hard tag until purposefully changed.  This also means the handle definitions use the last hard tag as a departing base for any further changes.</li>\r\n<li>It allows initial external basing and also external base substitution.  A trait can be based on an external trait or even module serving as a shell or casing for external function as long as any internal definitions don't overwrite the external ones.</li>\r\n<li>But, It forces internal basing once applied.  Definitions internal to the trait always take precedence over external definitions by the same signature.  This blocks external ancestor intrusion enforcing internal trait consistency. </li>\r\n<li>It keeps the VMC in proper working order.  Like all traits, the VMC is always available as a cache of methods available globally to all versions of the trait.</li>\r\n<li>Directives are allowed.  Also like all traits, JITI traits respond to normal trait injector directives.</li>\r\n</ol>\r\n\r\n<p>For more on this please see the rspec files in the project, or on the gem itself, and also visit our blog at <a href=\"http://jackbox.us\">http://jackbox.us</a></p>\r\n\r\n<p>But, this is the basic idea here.  Traits are an extended closure which can be used as a mix-in, prolonged to add function, and shaped,  versioned, tagged, and inherited to fit the purpose at hand. With Traits however you avoid the perils of monkey patching.  You can just create a new version of the trait and leave the old one alone.  Combining work flows of both modules and traits is also possible through the use of the VMC and the special version of #define_method.  Moreover, using traits Jackbox also goes on to solve some traditional shortcomings of Ruby with some GOF(Gang of Four) object patterns.  </p>\r\n\r\n<hr>\r\n\r\n<h3><a id=\"user-content-the-gof-decorator-pattern\" class=\"anchor\" href=\"#the-gof-decorator-pattern\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>The GOF Decorator Pattern:</h3>\r\n\r\n<p>Traditionally this is only partially solved in Ruby through PORO decorators or the use of modules.  However, there are the problems of loss of class identity for the former and the limitations on the times it can be re-applied to the same object for the latter. With Jackbox this is solved.  A trait used as a decorator does not confuse class identity for the receiver. Decorators are useful in several areas of OOP: presentation layers, string processing, command processors to name a few.  </p>\r\n\r\n<p>Here is the code:</p>\r\n\r\n<pre><code>class Coffee\r\n    def cost\r\n        1.50\r\n    end\r\nend\r\n\r\ntrait :milk do\r\n    def cost\r\n        super() + 0.30\r\n    end\r\nend\r\ntrait :vanilla do\r\n    def cost\r\n        super() + 0.15\r\n    end\r\nend\r\n\r\ncup = Coffee.new.enrich(milk).enrich(vanilla)\r\n  cup.should be_instance_of(Coffee)\r\n\r\ncup.cost.should == 1.95\r\n</code></pre>\r\n\r\n<p>Additionally, these same decorators can then be re-applied MULTIPLE TIMES to the same receiver.  This is something that is normally not possible with the regular Ruby base language.  Here is the code:</p>\r\n\r\n<pre><code>cup = Coffee.new.enrich(milk).enrich(vanilla).enrich(vanilla)\r\n\r\n# or even...\r\n\r\ncup = Coffee.new.enrich milk, vanilla, vanilla\r\n\r\ncup.cost.should == 2.10\r\ncup.should be_instance_of(Coffee)\r\ncup.traits.should == [:milk, :vanilla, :vanilla]\r\n\r\n# Important Note:\r\n# vanilla and coffe can be div tags \r\n# and other markup in html or... \r\n</code></pre>\r\n\r\n<h3><a id=\"user-content-other-capabilities-of-trait-injectors\" class=\"anchor\" href=\"#other-capabilities-of-trait-injectors\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>Other Capabilities of Trait Injectors</h3>\r\n\r\n<p>The functionality of Trait Injectors can be removed from individual targets, whether class or instance targets, in various different ways.  This allows for whole 'classes' of functionality to be removed and made un-available and then available again at whim and under programer control.  First we have trait canceling or ejection.  This is where a trait is completely removed from a target precipitating further calls on the trait to generate an error.  Second there is trait silencing and reactivation.  This on the other hand allows for the temporary quieting of a trait but which may need to be reactivated at a later time.</p>\r\n\r\n<p>Trait canceling or ejection can take place at the instance or the class level. Here we have a Trait Injector removed after an #enrich to individual instance:</p>\r\n\r\n<pre><code>class Coffee\r\n    def cost\r\n        1.00\r\n    end\r\nend\r\ntrait :milk do\r\n    def cost\r\n        super() + 0.50\r\n    end\r\nend\r\n\r\ncup = Coffee.new.enrich(milk)\r\nfriends_cup = Coffee.new.enrich(milk)\r\n\r\ncup.cost.should == 1.50\r\nfriends_cup.cost.should == 1.50\r\n\r\ncup.cancel :milk\r\n\r\ncup.cost.should == 1.00\r\n\r\n# friends cup didn't change price\r\nfriends_cup.cost.should == 1.50\r\n</code></pre>\r\n\r\n<p>Here it is removed after an #inject at the class level:</p>\r\n\r\n<pre><code># create the injection\r\nclass Home\r\n    trait :layout do\r\n        def fractal\r\n        end\r\n    end\r\n    inject layout\r\nend\r\nexpect{Home.new.fractal}.to_not raise_error\r\n\r\n# build\r\nmy_home = Home.new\r\nfriends = Home.new\r\n\r\n# eject the code\r\nclass Home\r\n    eject :layout\r\nend\r\n\r\n# the result\r\nexpect{my_home.fractal}.to raise_error\r\nexpect{friends.fractal}.to raise_error\r\nexpect{Home.new.fractal}.to raise_error\r\n</code></pre>\r\n\r\n<p>The code for these examples makes use of the #cancel alias #eject method which opens the door to this additional functionality provided by traits.  See also the Strategy Pattern just below this. It is important to keep in mind that ejection is \"permanent\" (not really, can always be re-injected) and that this permanence is more of its intent.  There are other ways to control code presence in targets through the use of Injector Directives.  See below.  For more on this also see the rspec examples.</p>\r\n\r\n<h4><a id=\"user-content-cancel-sym--alias-eject\" class=\"anchor\" href=\"#cancel-sym--alias-eject\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>#cancel *sym  (alias #eject)</h4>\r\n\r\n<p>This method cancels or ejects trait function from a single object or class.  It is in scope on any classes injected or enriched with a trait.  Its effect is that of completely removing one of our modular closures from the ancestor chain.  Once this is done method calls on the trait will raise an error.  </p>\r\n\r\n<h3><a id=\"user-content-injector-directives\" class=\"anchor\" href=\"#injector-directives\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>Injector Directives</h3>\r\n\r\n<p>Once you have a trait handle you can also use it to issue directives to the trait.  These directives can have a profound effect on your code.  There are directives to silence a trait, to reactivate it, to create a soft tag, or to completely obliterate the trait including the handle to it.</p>\r\n\r\n<h4><a id=\"user-content-silencecollapse-directive\" class=\"anchor\" href=\"#silencecollapse-directive\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>:silence/:collapse directive</h4>\r\n\r\n<p>This description produces similar results to the one for trait ejection (see above) except that further trait method calls DO NOT raise an error.  They just quietly return nil. Here are a couple of different cases:</p>\r\n\r\n<p>The case with multiple object instances:</p>\r\n\r\n<pre><code>trait :copiable do\r\n    def object_copy\r\n        'a dubious copy'\r\n    end\r\nend\r\n\r\no1 = Object.new.enrich(copiable)\r\no2 = Object.new.enrich(copiable)\r\n\r\no1.object_copy.should == 'a dubious copy'\r\no2.object_copy.should == 'a dubious copy'\r\n\r\ncopiable :silence\r\n\r\no1.object_copy.should == nil\r\no2.object_copy.should == nil\r\n</code></pre>\r\n\r\n<p>The case with a class receiver:</p>\r\n\r\n<pre><code>class SomeClass\r\n    trait :code do\r\n        def tester\r\n            'boo'\r\n        end\r\n    end\r\n\r\n    inject code\r\nend\r\n\r\na = SomeClass.new\r\nb = SomeClass.new\r\n\r\n# collapse\r\nSomeClass.code :collapse\r\n\r\na.tester.should == nil\r\nb.tester.should == nil\r\n</code></pre>\r\n\r\n<h4><a id=\"user-content-activerebuild-directive\" class=\"anchor\" href=\"#activerebuild-directive\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>:active/:rebuild directive</h4>\r\n\r\n<p>Trait Injectors that have been silenced or collapsed can at a later point be reactivated.  Here are a couple of cases:</p>\r\n\r\n<p>The case with multiple object receivers:</p>\r\n\r\n<pre><code>trait :reenforcer do\r\n    def thick_walls\r\n        '=====|||====='\r\n    end\r\nend\r\n\r\no1 = Object.new.enrich(reenforcer)\r\no2 = Object.new.enrich(reenforcer)\r\n\r\nreenforcer :collapse\r\n\r\no1.thick_walls.should == nil\r\no2.thick_walls.should == nil\r\n\r\nreenforcer :rebuild\r\n\r\no1.thick_walls.should == '=====|||====='\r\no2.thick_walls.should == '=====|||====='\r\n</code></pre>\r\n\r\n<p>The case with a class receiver:</p>\r\n\r\n<pre><code>class SomeBloatedObject\r\n    trait :ThinFunction do\r\n        def perform\r\n            'do the deed'\r\n        end\r\n    end\r\n    inject ThinFunction()\r\nend\r\nSomeBloatedObject.ThinFunction :silence  # alias to :collapse\r\n\r\ntester = SomeBloatedObject.new\r\ntester.perform.should == nil\r\n\r\nSomeBloatedObject.ThinFunction :active   # alias to :rebuild\r\ntester.perform.should == 'do the deed'\r\n</code></pre>\r\n\r\n<h4><a id=\"user-content-tagversion-directive\" class=\"anchor\" href=\"#tagversion-directive\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>:tag/:version directive</h4>\r\n\r\n<p>This directive creates a soft tagged version of a trait.  For more on this see Soft Tags below.</p>\r\n\r\n<h4><a id=\"user-content-implode-directive\" class=\"anchor\" href=\"#implode-directive\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>:implode directive</h4>\r\n\r\n<p>This directive totally destroys the trait including the handle to it.  Use it carefully!</p>\r\n\r\n<pre><code>class Model\r\n    def feature\r\n        'a standard feature'\r\n    end\r\nend\r\n\r\ntrait :extras do\r\n    def feature\r\n        super() + ' plus some extras'\r\n    end\r\nend\r\n\r\ncar = Model.new.enrich(extras)\r\ncar.feature.should == 'a standard feature plus some extras'\r\n\r\nextras :implode\r\n\r\n# total implosion\r\ncar.feature.should == 'a standard feature'\r\n\r\nexpect{extras}.to raise_error(NameError, /extras/)\r\nexpect{ new_car = Model.new.enrich(extras) }.to raise_error(NameError, /extras/)\r\nexpect{\r\n    extras do\r\n        def foo\r\n        end\r\n    end\r\n    }.to raise_error(NameError, /extras/)\r\n</code></pre>\r\n\r\n<h3><a id=\"user-content-the-gof-strategy-pattern\" class=\"anchor\" href=\"#the-gof-strategy-pattern\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>The GOF Strategy Pattern:</h3>\r\n\r\n<p>Another pattern that Jackbox helps with is the GOF Strategy Pattern.  This is a pattern which changes the guts of an object as opposed to just changing its outer shell. Traditional examples of this pattern in Ruby use PORO component injection within constructors, and then a form of delegation.  With Jackbox Trait Injectors all this is eliminated.  </p>\r\n\r\n<p>Here are a couple alternate implementations:</p>\r\n\r\n<pre><code>class Coffee\r\n    attr_reader :strategy\r\n\r\n    def initialize\r\n      @strategy = nil\r\n    end\r\n    def cost\r\n        1.00\r\n    end\r\n  def brew\r\n        @strategy = 'normal'\r\n  end\r\nend\r\n\r\ncup = Coffee.new\r\ncup.brew\r\ncup.strategy.should == 'normal'\r\n\r\n\r\ntrait :sweedish do\r\n    def brew\r\n        @strategy = 'sweedish'\r\n    end\r\nend\r\n\r\ncup = Coffee.new.enrich(sweedish)           # clobbers original strategy for this instance only!!\r\ncup.brew\r\ncup.strategy.should == ('sweedish')\r\n</code></pre>\r\n\r\n<p>But, with #cancel/#eject it is possible to have an even more general alternate implementation. This time we completely replace the current strategy by actually ejecting it out of the class and then injecting a new one:</p>\r\n\r\n<pre><code>class Tea &lt; Coffee  # Tea is a type of coffee!! ;~Q)\r\n    trait :SpecialStrategy do\r\n        def brew\r\n            @strategy = 'special'\r\n        end\r\n    end\r\n    inject SpecialStrategy()\r\nend\r\n\r\ncup = Tea.new\r\ncup.brew\r\ncup.strategy.should == 'special'\r\n\r\nTea.eject :SpecialStrategy\r\n\r\nTea.inject sweedish\r\n\r\ncup.brew\r\ncup.strategy.should == 'sweedish'\r\n</code></pre>\r\n\r\n<h3><a id=\"user-content-soft-tags\" class=\"anchor\" href=\"#soft-tags\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>Soft Tags</h3>\r\n\r\n<p>Just like hard tags above but a name is not needed:</p>\r\n\r\n<pre><code>jack :SomeJack do\r\n  def foo\r\n    :foo\r\n  end\r\nend\r\nSomeJack :tag                       # Unnamed version\r\n\r\nSomeJack(:tag) do                   # New unnamed version\r\n  def foo\r\n    :foooooooo\r\n  end\r\nend\r\n</code></pre>\r\n\r\n<p>Accessible through trait#tags (an Array).  Also available <strong>trait#tags.hard</strong> and <strong>trait#tags.soft</strong>.  See introspection above.</p>\r\n\r\n<hr>\r\n\r\n<h3><a id=\"user-content-patterns-of-a-different-flavor\" class=\"anchor\" href=\"#patterns-of-a-different-flavor\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>Patterns of a Different Flavor</h3>\r\n\r\n<p>Jackbox Traits also make possible some additional coding patterns.  Although not part of the traditional GOF set these new patterns are only possible thanks to languages like Ruby that although not as flexible as Lisp, permit the morphing of normal forms into newer ones. We hope that as Ruby evolves it continues to give programmers more power redefining the language itself. Here are some new patterns: </p>\r\n\r\n<p><strong>1) Late Decorator.-</strong> Another flow that also benefits from #define_method in an interesting way is the following:   </p>\r\n\r\n<pre><code>class Widget\r\n    def cost\r\n        1\r\n    end\r\nend\r\nw = Widget.new\r\n\r\ntrait :decorator\r\n\r\nw.enrich decorator, decorator, decorator, decorator\r\n\r\n# user input\r\nbid = 3.5 \r\n\r\ndecorator do\r\n    define_method :cost do                      # defines function on all traits of the class\r\n        super() + bid\r\n    end\r\nend\r\n\r\nw.cost.should == 15\r\n</code></pre>\r\n\r\n<p>The actual decorating trait function is late bound and defined only after some other data is available.</p>\r\n\r\n<p><strong>2) The Super Pattern.-</strong> No.  This is not a superlative kind of pattern.  Simply, the use of #super can be harnessed into a pattern of controlled recursion, like in the following example: </p>\r\n\r\n<pre><code>trait :Superb\r\n\r\nSuperb do\r\n    def process string, additives, index\r\n        str = string.gsub('o', additives.slice!(index))\r\n        super(string, additives, index) + str rescue str\r\n    end\r\n    extend Superb(), Superb(), Superb()\r\nend   \r\n\r\nSuperb().process( 'food ', 'aeiu', 0 ).should == 'fuud fiid feed faad '\r\nSuperb(:implode)                                 \r\n</code></pre>\r\n\r\n<p><strong>3) The Solutions Pattern.-</strong>  For a specific example of what can be accomplished using this workflow please refer to the rspec directory under the transformers spec.  Here is the basic flow:</p>\r\n\r\n<pre><code>jack :Solution\r\n\r\nSolution( :tag ) do\r\n    def solution\r\n        1\r\n    end\r\nend\r\nSolution( :tag ) do\r\n    def solution\r\n        2\r\n    end\r\nend\r\nSolution( :tag ) do\r\n    def solution\r\n        3\r\n    end\r\nend\r\n\r\n\r\nclass Client\r\n    inject Solution()\r\n\r\n    def self.solve\r\n        Solution().tags.each { |e|\r\n            update e \r\n            puts new.solution rescue nil\r\n        }                              \r\n\r\n        # or...\r\n\r\n        solutions = Solution().tags.each\r\n        begin\r\n            update solutions.next\r\n            puts solved = new().solution()\r\n        end until solved\r\n        solved\r\n    end\r\n\r\nend\r\n\r\nClient.solve\r\n</code></pre>\r\n\r\n<p><strong>4) The Class Constructor Pattern.-</strong>  Our base method #lets has one more interesting use which allows for an alternative way to refine classes.  We have originally termed this Re-Classing but after further consideration and user input we have refocused the intent of this pattern and we now define it as class constructors.  Look at the following code:</p>\r\n\r\n<pre><code>    module Work\r\n        lets String do\r\n            def self.new(*args)\r\n                \"+++#{super}+++\"\r\n            end\r\n        end\r\n    end\r\n\r\n    class WorkAholic\r\n        include Work\r\n\r\n        def work_method\r\n            String('Men-At-Work')\r\n        end\r\n    end\r\n\r\n    str = WorkAholic.new.work_method              # Our String re-class\r\n    str.should == '+++Men-At-Work+++'\r\n\r\n    str = String.new('men-at-work')               # Regular String\r\n    str = 'men-at-work'\r\n\r\n    str = String('Men-At-Work')                                     # Regular Kernel version\r\n    str = 'Men-At-Work'\r\n</code></pre>\r\n\r\n<p>The important thing to remember here is that #String() is a method now. We can redefine it, name-space it, test for its presence, etc.  We can also use it to redefine the class's methods.  </p>\r\n\r\n<pre><code>jack :Log do\r\n    require 'logger'\r\n\r\n    def to_log arg\r\n        (@log ||= Logger.new($stdout)).warn(arg)\r\n    end\r\nend\r\n\r\nString() do\r\n    inject Log()\r\n\r\n    def show\r\n        to_log self\r\n    end\r\nend\r\n\r\nstr = String('don't leave a trace')\r\nstr.show                                      # doh!!\r\n</code></pre>\r\n\r\n<p>For more on this see, the rspec files and the Jackbox blog at <a href=\"http://jackbox.us\"></a><a href=\"http://jackbox.us\">http://jackbox.us</a>.  </p>\r\n\r\n<h4><a id=\"user-content-reclassklass\" class=\"anchor\" href=\"#reclassklass\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>#reclass?(klass)</h4>\r\n\r\n<p>This helper verifies a certain re-class exists within the current namespace.  It returns a boolean.  Example:</p>\r\n\r\n<pre><code>module One\r\n  if reclass? String\r\n    String('our string')\r\n  end\r\nend\r\n</code></pre>\r\n\r\n<p>For more information and additional examples see the rspec examples on this project.  There you'll find a long list of over <strong>250</strong> rspec examples and code showcasing features of Jackbox Injectors along with some additional descriptions.</p>\r\n\r\n<hr>\r\n\r\n<h2><a id=\"user-content-additional-tools\" class=\"anchor\" href=\"#additional-tools\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>Additional Tools</h2>\r\n\r\n<p>Jackbox includes a couple of additional ancillary tools.  The first is an Abstract class base that prevents instantiation of the base class itself but not of its descendants.  The second is a persistent properties module named Prefs; it creates class/module/namespace level persistent properties.</p>\r\n\r\n<p>With Abstract the code goes like this:</p>\r\n\r\n<pre><code>class Vector\r\n    extend Abstract\r\n    def speed\r\n        0\r\n    end\r\n    def direction\r\n    end\r\nend\r\nexpect{Vector.new}.to raise_error\r\n\r\nclass Velocity &lt; Vector\r\n    def speed\r\n        super + 35\r\n    end\r\n    def direction\r\n        :north\r\n    end\r\nend\r\n\r\nexpect{Velocity.new}.to_not raise_error\r\nVelocity.new.speed.should == 35\r\n</code></pre>\r\n\r\n<p>With Prefs you can add persistent properties to a class.  These properties persist even through program termination. Here is the example code:</p>\r\n\r\n<pre><code>module Jester\r\n    extend Prefs\r\n\r\n    pref :value =&gt; 10\r\nend\r\n\r\nJester.value.should == 10\r\nJester.value = 3\r\nJester.value.should == 3\r\nJester.reset :value\r\nJester.value.should == 10 \r\n</code></pre>\r\n\r\n<p>There is also command line utility called <strong>jackup</strong> that simply allows users to bring projects up to a <em>\"Jackbox level\"</em>.  It inserts the right references and turns the targeted project into a bundler gem if it isn't already one also adding a couple of rake tasks.</p>\r\n\r\n<h2><a id=\"user-content-availability\" class=\"anchor\" href=\"#availability\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>Availability</h2>\r\n\r\n<p>Jackbox is current available for Linux, Mac, and Windows versions of Ruby 1.9.3 thru 2.2.1</p>\r\n\r\n<h2><a id=\"user-content-installation\" class=\"anchor\" href=\"#installation\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>Installation</h2>\r\n\r\n<p>Add this line to your application's Gemfile:</p>\r\n\r\n<pre><code>gem 'jackbox'\r\n</code></pre>\r\n\r\n<p>And then execute:</p>\r\n\r\n<pre><code>$ bundle\r\n</code></pre>\r\n\r\n<p>Or install it yourself as:</p>\r\n\r\n<pre><code>$ gem install jackbox\r\n</code></pre>\r\n\r\n<p>And then execute the following command inside the project directory:</p>\r\n\r\n<pre><code>$jackup \r\n</code></pre>\r\n\r\n<h2><a id=\"user-content-support\" class=\"anchor\" href=\"#support\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>Support</h2>\r\n\r\n<p>Any questions/suggestions can be directed to the following email address: </p>\r\n\r\n<p><strong><a href=\"mailto:service.delivered@ymail.com\">service.delivered@ymail.com</a></strong>.  </p>\r\n\r\n<p>Please include your platform along with a description of the problem and any available stack trace.  Please keep in mind that, at this time we have limited staff and we will do our best to have a quick response time. </p>\r\n\r\n<p>Also please follow us at <a href=\"http://jackbox.us\">http://jackbox.us</a></p>\r\n\r\n<h2><a id=\"user-content-licensing\" class=\"anchor\" href=\"#licensing\" aria-hidden=\"true\"><span aria-hidden=\"true\" class=\"octicon octicon-link\"></span></a>Licensing</h2>\r\n\r\n<p>Jackbox single use and multi-use licenses are free.\r\nCopyright © 2014, 2015 LHA. All rights reserved.</p>\r\n\r\n<p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\nNON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>\r\n\r\n<p>In the above copyright notice, the letters LHA are the english acronym \r\nfor Luis Enrique Alvarez (Barea) who is the author and owner of the copyright.</p>","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}