{"name":"Jackbox","tagline":"Ruby Code Injectors: Jackbox","body":"<script>\r\n  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){\r\n  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),\r\n  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)\r\n  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');\r\n\r\n  ga('create', 'UA-58877141-2', 'auto');\r\n  ga('send', 'pageview');\r\n\r\n</script>\r\n<!---\r\n# @author Lou Henry Alvarez\r\n-->\r\nCopyright © 2014 LHA. All rights reserved.\r\n\r\nJackbox   <a href=\"https://plus.google.com/102732809517976898938\" rel=\"publisher\">Google+</a>\r\n=======\r\n\r\nJackbox is a set of programming tools which enhance the Ruby language and provide additional software constructs.  \r\n\r\nThe main library function at this time centers around the concept of code Injectors.  To make it easier to grasp the idea behind them, these can perhaps be thought of as an **extended closure** or a form of closure which can also serve as module.  But, most of all Injectors propose some additional interesting properties to the idea of a mix-in.  For instance, they give your code the ability to capture your methods' surrounding context and introduce it into an indiscriminate target.  They make it possible to solve several general problems in the areas of OOP and GOF standard and traditional Ruby shortcomings with the GOF Decorator and Strategy Patterns.  They instrument control over the presence of injector code in targets with mechanisms involving injector ejection and directives.  Finally, they introduce the concept of injector versioning.  This is a feature which allows you to redefine parts of your program in local isolation and without it affecting others.  See Injector Versioning below.  \r\n\r\nBasic Methods\r\n--------------------------\r\nThere are some basic Jackbox methods.  The are just rudimentary helpers, which in effect are a form of syntax sugar for every day things.  These are their descriptions:\r\n\r\n#### #decorate(:sym, &blk)\r\nThis method allows for decorations to be placed on a single method, be it an instance or class method without too much fuss. It also makes possible the use of ruby's keyword :super within the body of the decorator.  Use it instead of #alias\\_method\\_chain.\r\n\r\nExamples:\r\n\r\n    # some class\r\n    class One\r\n      def foo\r\n        'foo '\r\n      end\r\n    end\r\n    # then...\r\n    \r\n\r\nAt the class level during definition:\r\n\r\n    # the same class\r\n    class One\r\n      decorate :foo do\r\n        super() + 'decoration '                   # super available within decoration\r\n      end\r\n    end\r\n\r\n    One.new.foo\r\n    #=> foo decoration\r\n\r\n\r\nAt the object level during execution:\r\n\r\n    one = One.new\r\n\r\n    one.decorate :foo do |arg|\r\n      super() + arg                               # again the use of super is possible\r\n    end\r\n\r\n    one.foo('after')\r\n    #=> foo decoration after\r\n\r\n\r\nIt also works like so:\r\n\r\n    Object.decorate :inspect do\r\n      puts super() + \" is your object\"\r\n    end\r\n\r\n    Object.new.inspect\r\n    #=> #<Object:0x00000101787e20> is your object\r\n\r\n\r\n#### #with(obj, &blk)\r\nThere is also a new version of the :with construct.  The important thing to remember about #with is it has a primary context which is the object passed to it, and a secondary context which is the object you are making the call from.  Here is the sample usage code:\r\n\r\n    class One\r\n      def foo(arg)\r\n        'in One ' + arg\r\n      end\r\n    end\r\n\r\n    class Two\r\n      def faa(arg)\r\n        'and in Two ' + arg\r\n      end\r\n      def meth\r\n        with One.new do\r\n          return foo faa 'with something'         # context of One and Two available simultaneously!!!\r\n        end\r\n      end\r\n    end\r\n\r\n    Two.new.meth\r\n    #=> 'in One and in Two with something'\r\n\r\n\r\nUse it with #decorate on singleton classes like this:\r\n\r\n    class Dir\r\n\r\n      with singleton_class do\r\n        decorate :entries do |name='.', opts=nil| #:doc:\r\n          super name, opts\r\n        end\r\n        decorate :new do |name, &code| #:doc:\r\n          FileUtils.mkpath name unless exists?(name)\r\n          return Dir.open(name, &code) if code\r\n          Dir.open name\r\n        end\r\n      end\r\n\r\n    end\r\n\r\nOr its use in the following method:\r\n\r\n    def add_line(spec)\r\n      open spec[:to], 'r+' do |file|\r\n        lines = file.readlines\r\n        file.rewind\r\n\r\n        index = 0\r\n        # look for the first 'require' line in file\t\t\t\t\r\n        lines.each_with_index { |line, i| \r\n          if line.match(/^require/).nil?\r\n            break if index != i\r\n            index = i + 1\r\n            next\r\n          else\r\n            index = i\r\n          end \r\n        }\r\n        # insert our line after check to see not already there\r\n        with lines do\r\n          format = spec[:format] || required\r\n          unless join.match(Regexp.new(format.join('|')))\r\n            insert(\r\n              index && index + 1 || 0, format.last\r\n            ) \r\n          end\r\n        end\r\n\r\n        file.write lines.join\r\n      end\r\n    end\r\n\r\n\r\n#### #lets(sym=nil, &blk)\r\nThis is simple syntax sugar.  It allows the creation of local or global procs using a more function-like syntax.  It adds readability to some constructs.  Here are some examples:\r\n\r\nTo define local functions/lambdas. Define symbols in local scope:\r\n\r\n    def main\r\n      lets bar =->(arg){ arg * arg }              # read as lets set bar to lambda/proc \r\n\r\n      # later on ...\r\n\r\n      var = bar[3]                                # bar is only available within #main\r\n      #...\r\n    end\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\r\nAs a shortcut for define_method. Use it for short functional definitions:\r\n\r\n    lets( :meth ){ |arg| arg * 2 }                # read as lets define symbol :meth to be ....\r\n    meth(3)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n    # => 6 \r\n\r\nCan be used to define a special values or pseudo-immutable strings:\r\n\r\n    lets(:foo){3+Math::Pi}                        # read as lets set :foo to value\r\n    lets(:faa){ 'some important string' }\r\n    \r\n\r\nInjectors\r\n----------\r\nInjectors are the main tool in Jackbox at the time of this writing --real meat of Jackbox. These again are an extended closure, a form of mix-in that has properties of both a closure and a module.  They are an extended closure if you will.  In the sections below we will discuss some of the methods available to you with Jackbox in connection with Injectors. There are some syntactical differences to Injectors with respect to regular modules.  We will show them first, with some examples: \r\n\r\n**Injectors are declared in the following ways:**\r\n\r\n\r\n    injector :name\r\n\r\n    #  or...\r\n\r\n    Name = injector :name\r\n\r\n    # or even ...\r\n\r\n    injector :Name                                # capitalized method\r\n\r\n\r\nTheir use and semantics are somewhat defined by the following snippet.  But, to fully understand their implications to your code, you have to understand the section on injector versioning, and perhaps injector directives. \r\n\r\n    # somewhere in your code\r\n    include Injectors\r\n\r\n    injector :my_injector                         # define the injector \r\n    \r\n    my_injector do                     \r\n      def bar                  \r\n        :a_bar\r\n      end\r\n    end\r\n\r\n    # later on...\r\n    widget.enrich my_injector\r\n    widget.bar\r\n\r\n    # or...  \r\n    Mine = my_injector\r\n    class Target\r\n      inject Mine                                 # apply the injector\r\n    end\r\n    \r\n    Target.new.bar\r\n\r\n    module None\r\n      facet :f\r\n\r\n      class Bone\r\n        inject None.f\r\n      end\r\n    end\r\n\r\n    # etc ...\r\n\r\n\r\n**Injectors can have prolongations:**\r\n\r\n    my_injector do                                # first prolongation\r\n\r\n      def another_method\r\n      end\r\n\r\n    end\r\n\r\n    # ...\r\n\r\n    my_injector do                                # another prolongation\r\n\r\n      def yet_another_method\r\n      end\r\n\r\n    end\r\n\r\n\r\n\r\n#### #injector(:sym)   #=> j\r\nThis is the main method.  It defines an object of type Injector with the name of symbol :sym.  Use it when you want to generate an Injector object for later use.  The symbol can then be used as a handle to the injector whenever you need to prolong the injector by adding methods to it or apply it to another object.\r\n\r\nHere is a more interesting example:\r\n\r\n    class ClosureExpose\r\n\r\n    \tsome_value = 'something'\r\n\t\r\n    \tinjector :capture do\r\n    \t\tdefine_method :val do\r\n    \t\t\tsome_value\r\n    \t\tend\r\n    \tend\r\n\r\n    \tinject capture\r\n    end\r\n\r\n    class SecondClass\r\n    \tinject ClosureExpose.capture\r\n    end\r\n\r\n    # the result\r\n    SecondClass.new.val.should == 'something'\r\n\r\nFor all this to happen Jackbox also introduces some additional ruby constructs, namely the keywords #inject and #enrich.  These can be thought of as simply new corollaries to #include and #extend. If you're working with injectors you need to use them depending on context as some of the functionality of Injectors is related to them.\r\n\r\n#### #inject(*j*)\r\nThis method is analogous to ruby's #include but its use is reserved for Injectors.  The scope of this method is the same as the scope of #include, and its intended use is for class definitions. Use it to \"include\" an Injector into a receiving class.\r\n\r\n#### #enrich(*j*)\r\nThis method in turn is analogous to ruby's #extend. The scope of this method is also the same as that of #extend, and its intended use if for object definition.  Use it to extend the receiver of an injector.\r\n\r\n### Injector Versioning\r\n\r\nOne of the most valuable properties of injectors is Injector Versioning.  Versioning is the term used to identify a feature in the code that produces an artifact of injection which contains a certain set of methods with their associated outputs, and represents a snapshot of that injector up until the point it's applied to an object.  From, that point on the object contains only that version of methods from that injector, and any subsequent overrides to those methods are only members of the \"prolongation\" of the injector and do not become part of the object of injection unless some form of re-injection occurs. Newer versions of an injector's methods only become part of newer objects or newer injections into existing targets.\r\n\r\n**Note: One important thing to remember about versioning is that it refers to re-definitions of methods in newer prolongations of the same injector and the relationship those methods have to the other members of the version and to client code.**\r\n\r\nWe'll use some examples to illustrate the point.  This is how versioning occurs:\r\n\r\n    #___________________\r\n    # injector declaration\r\n    injector :my_injector do \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n      def bar\r\n        :a_bar                                    # version bar.1\r\n      end\r\n      def foo\r\n      \t# ...\r\n      end\r\n    end\r\n\r\n    enrich my_injector                            # apply --snapshot:  to any object instance\r\n    bar.should == :a_bar                          # pass the test\r\n\r\n    #__________________\r\n    # injector prolongation\r\n    my_injector do \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n      def bar\r\n        :some_larger_bar                          # version bar.2 ... re-defines bar\r\n      end\r\n      def some_other_function\r\n      # ...\r\n      end\r\n    end\r\n\r\n    bar.should == :a_bar                          # bar.1 is still the one  \r\n\r\nWhen re-injection occurs, and only then does the new version of the #bar method come into play. Here is the code:\r\n\r\n    #_________________\r\n    # re-injection\r\n    enrich my_injector                            # re-injection: re-apply --snapshot on any object instance\r\n\r\n    bar.should == :some_larger_bar                # bar.2 now available\r\n    expect{some_other_function}.to_not raise_error      # some_other_function.1 is also present\r\n\r\n\r\nHere is an example with classes:\r\n\r\n    #___________________\r\n    # injector declaration:\r\n    Versions = injector :versions do\r\n      def meth arg                                # version meth.1\r\n        arg ** arg\r\n      end\r\n    end\r\n\r\n    class One\r\n      inject Versions                             # apply --first snapshot\r\n    end\r\n\r\n    #_________________\r\n    # injector prolongation:                              \r\n    versions do\r\n      def meth arg1, arg2                         # version meth.2 ... redefines meth.1\r\n        arg1 * arg2\r\n      end\r\n    end\r\n\r\n    class Two\r\n      inject Versions                             # apply --second snapshot\r\n    end\r\n\r\n\r\n    # result\r\n    Two.new.meth(2,4).should == 8                 # meth.2 \r\n                                                          # two different injector versions\r\n    One.new.meth(3).should == 27                  # meth.1\r\n\r\nRe-injection on classes is a little bit trickier.  Why? Because class injection is more pervasive --we don't necessarily want to be redefining a class at every step. To re-inject a class we must use the Strategy Pattern or use a private update.  See the rspec files for more on this.  \r\n\r\nRight now, we want to give some treatment to injector local binding.  That is, the binding of an injectors' methods is local to the prolongation/version in which they are located before the versioning occurs.  Here, is the code:\r\n\r\n    #_____________________\r\n    # injector declaration\r\n    injector :functionality do\r\n      def basic arg                               # version basic.1\r\n        arg * 2\r\n      end\r\n    end\r\n\r\n    o = Object.new.enrich functionality           # apply --first snapshot\r\n    o.basic(1).should == 2                        # basic.1 \r\n\r\n\r\n    #_____________________\r\n    # injector prolongation\r\n    functionality do\r\n      def basic arg                               # basic.2 ... basic.1 redefined\r\n        arg * 3\r\n      end\r\n\r\n      def compound                                # compound.1 --binding locally to basic.2 in this prolongation\r\n        basic(3) + 2                                      \r\n      end\r\n    end\r\n\r\n    p = Object.new.enrich(functionality)          # apply --second snapshot: like above\r\n    p.basic(1).should == 3                        # basic.2 \r\n    p.compound.should == 11                       # compound.1 \r\n    \r\n    o.basic(1).should == 2                        # basic.1 --NOT basic.2: like above\r\n\r\n                                                  #####################################################\r\n    o.compound.should == 11                       # compound.1 --local binding to basic.2 NOT basic.1\r\n                                                  #####################################################\r\n                                                          \r\nThere is one more interesting property however. The use of #define\\_method to re-define methods in any prolongation updates the entire injector and all its versions.  This preserves one of the fundamental tenets of injectors: being able to take some local context, enclose it and through the injector introduce it to some indiscriminate place. Here is an example of #define\\_method' difference:\r\n\r\n    SomeFacet = facet :some_facet do\r\n    \tdef foo_bar\r\n    \t\t'a foo and a bar'\r\n    \tend\r\n    end\r\n\r\n    class Client\r\n    \tinject SomeFacet\r\n    end\r\n\r\n    Client.new.foo_bar.should == 'a foo and a bar'      # expected\r\n\r\n    some_facet do\r\n    \tdefine_method :foo_bar do\r\n    \t\t'fooooo and barrrrr'\r\n    \tend\r\n    end\r\n\r\n    Client.new.foo_bar.should == 'fooooo and barrrrr'   # different than above\r\n\r\nInjector Versioning together with injector local binding allow you to mutate injectors to fit your particular purpose at hand and keep those local modifications isolated from the rest of your program making your code to naturally evolve with your program.\r\n\r\n\r\n### Multiple Injector composition\r\nThe composition of multiple injectors into an object can be specified as follows:\r\n\r\n    include Injectors\r\n    \r\n    # declare injectors\r\n    injector :FuelSystem\r\n    injector :Engines\r\n    injector :Capsule\r\n    injector :Landing\r\n\r\n    # compose the object\r\n    class SpaceShip\r\n    \tinject FuelSystem()\r\n    \tinject Engines()\r\n    \tinject Capsule()\r\n    \tinject Landing()\r\n\r\n    \tdef launch\r\n    \t\tgas_tank fuel_lines burners ignition :go\r\n    \t\tself\r\n    \tend\r\n    end\r\n\r\n\r\n    # define functionality\r\n    FuelSystem do\r\n    \tdef gas_tank arg\r\n    \t\t:gas\r\n    \tend\r\n\r\n    \tdef fuel_lines arg\r\n    \t\t:fuel\r\n    \tend\r\n\r\n    \tdef burners arg\r\n    \t\t:metal\r\n    \tend\r\n    end\r\n\r\n    # further define function\r\n    Engines do\r\n    \tdef ignition arg\r\n    \t\t:spark\r\n    \tend\r\n    end\r\n\r\n    # create object\r\n    flyer = SpaceShip.new.launch\r\n\r\n    # in flight definitions, ha ha!!\r\n    Capsule do\r\n    \tdef o2\r\n    \t\t:oxigen\r\n    \tend\r\n    \tdef hydration\r\n    \t\t:water\r\n    \tend\r\n    end\r\n\r\n    # more inflight definitions\r\n    var = 'wheels'\r\n    Landing do\r\n    \tdefine_method :gear do                    # a definintion based on available surrounding context\r\n    \t\tvar\r\n    \tend\r\n    end\r\n\r\n\r\n**IMPORTANT NOTE: Injector lookup follows the method and not the constant lookup algorithm.**\r\n\r\nIf you need to follow constant lookup, here is the code for that:\r\n\r\n    Name = injector :sym ....\r\n\r\nBut, this is the basic idea here.  Using this approach Jackbox goes on to solve the Decorator Pattern problem for the Ruby language.  \r\n\r\n\r\n### The GOF Decorator Pattern:   \r\nTraditionally this is only partially solved in Ruby through PORO decorators or the use of modules.  However, there are the problems of loss of class identity for the former and the limitations on the times it can be re-applied to the same object for the latter. With Jackbox this is solved.  An injector used as a decorator does not confuse class identity for the receiver. \r\n\r\nHere is the code for that:\r\n\r\n\tclass Coffee\r\n\t\tdef cost\r\n\t\t\t1.50\r\n\t\tend\r\n\tend\r\n\r\n\tinjector :milk do\r\n\t\tdef cost\r\n\t\t\tsuper() + 0.30\r\n\t\tend\r\n\tend\r\n\tinjector :sprinkles do\r\n\t\tdef cost\r\n\t\t\tsuper() + 0.15\r\n\t\tend\r\n\tend\r\n\t\r\n\tcup = Coffee.new.enrich(milk).enrich(sprinkles)\r\n\tcup.should be_instance_of(Coffee)\r\n\r\n\tcup.cost.should == 1.95\r\n\r\n\r\nFurthermore, these decorators can be re-applied multiple times to the same receiver:\r\n\r\n\tcup = Coffee.new.enrich(milk).enrich(sprinkles).enrich(sprinkles)\r\n\t# or even..\r\n\tcup = Coffee.new.enrich milk, sprinkles, sprinkles\r\n\r\n\tcup.cost.should == 2.10\r\n\tcup.should be_instance_of(Coffee)\r\n\tcup.injectors.should == [:milk, :sprinkles, :sprinkles]\r\n\t\r\nDecorators are useful in several areas of OOP: graphics, stream processing, command processors to name a few.\r\n\r\n\r\n### Injector introspection\r\nInjectors have the ability to speak about themselves and inject their receivers with these introspecting capabilities.  Every injected/enriched object or class can enumerate its injectors.  Moreover injectors can speak about its members just like any module or class.\r\n    \r\n    class Target\r\n    end\r\n\r\n    injector :Function do\r\n      def far\r\n        puts :faaaar\r\n      end\r\n    end\r\n    injector :Style do\r\n    \tdef pretty\r\n    \t\t'oohooo'\r\n    \tend\r\n    end\r\n\r\n    Target.inject Function(), Style()\r\n\r\n    Target.injectors.should == [:Function, :Style] \r\n\r\n    Function().instance_methods.should == [:far]\r\n    Style().instance_methods.should == [:pretty]    \r\n\r\n    \r\n#### #injectors(*syms)\r\nCalled with no arguments returns a list of injector symbols.  A call with a list of injector symbols however returns an array of actual Injector objects. An example use goes like this:\r\n\r\n    class Target\r\n      inject function\r\n      inject style\r\n    end\r\n    \r\n    # later on...\r\n    Target.injectors.each{ |ij| Target.eject ij }  \r\n\r\n\r\n### Other Capabilities of Injectors\r\n\r\nThe functionality of an injector can be removed from an #enrich to individual objects:\r\n\t\r\n  \tclass Coffee\r\n  \t\tdef cost\r\n  \t\t\t1.00\r\n  \t\tend\r\n  \tend\r\n  \tinjector :milk do\r\n  \t\tdef cost\r\n  \t\t\tsuper() + 0.50\r\n  \t\tend\r\n  \tend\r\n\r\n  \tcup = Coffee.new.enrich(milk)\r\n  \tfriends_cup = Coffee.new.enrich(milk)\r\n\r\n  \tcup.cost.should == 1.50\r\n  \tfriends_cup.cost.should == 1.50\r\n\r\n  \tcup.eject :milk\r\n  \t\r\n  \tcup.cost.should == 1.00\r\n  \t\r\n  \t# friends cup didn't change price\r\n  \tfriends_cup.cost.should == 1.50\r\n  \t\r\nOr, from an #inject at the class level:\r\n\r\n    # create the injection\r\n    class Home\r\n    \tinjector :layout do\r\n    \t\tdef fractal\r\n    \t\tend\r\n    \tend\r\n    \tinject layout\r\n    end\r\n    expect{Home.new.fractal}.to_not raise_error\r\n\r\n    # build\r\n    my_home = Home.new\r\n    friends = Home.new\r\n\r\n    # eject the code\r\n    class Home\r\n    \teject :layout\r\n    end\r\n\r\n    # the result\r\n    expect{my_home.fractal}.to raise_error\r\n    expect{friends.fractal}.to raise_error\r\n    expect{Home.new.fractal}.to raise_error\r\n\r\n\t\r\nThe code for this makes use of :eject which is also part of Jackbox and opens the door to some additional functionality provided by injectors.  This additional function allows Injectors to be truly used to inject and eject code at will.\r\n\r\n#### :eject(sym)\r\nThis method ejects injector function from a single object or class.  For other forms of injector withdrawal see the next sections.  It is in scope on any classes injected or enriched by an injector.  With this capability we can do the following with our Spaceship example from above:\r\n\r\n    SpaceShip.injectors.should == [:FuelSystem, :Engines, :Capsule, :Landing]\r\n    flyer.injectors.should == [:FuelSystem, :Engines, :Capsule, :Landing]\r\n    flyer.fuel_lines :on\r\n    flyer.ignition :on\r\n    flyer.o2\r\n    flyer.gear.should == 'wheels'\r\n\r\n    # eject class level injector at the object level\r\n    flyer.eject :Capsule\r\n\r\n    # expect errors\r\n    SpaceShip.injectors.should == [:FuelSystem, :Engines, :Capsule, :Landing]\r\n    flyer.injectors.should == [:FuelSystem, :Engines, :Landing]\r\n    expect{flyer.o2}.to raise_error\r\n    flyer.fuel_lines :dead\r\n    flyer.ignition :on\r\n    flyer.gear.should == 'wheels'\r\n\r\n\r\nFor more details see the Rspec examples in this project.\r\n\r\n### The GOF Strategy Pattern:\r\nAnother pattern that Jackbox helps with is the GOF Strategy Pattern.  This is a pattern with changes the guts of an object as opposed to just changing its face. Traditional examples of this pattern use PORO component injection within constructors. \r\n\r\nHere are a couple alternate implementations:\r\n\r\n    class Coffee\r\n    \tattr_reader :strategy\r\n\r\n    \tdef initialize\r\n    \t  @strategy = nil\r\n    \tend\r\n    \tdef cost\r\n    \t\t1.00\r\n    \tend\r\n      def brew\r\n    \t\t@strategy = 'normal'\r\n      end\r\n    end\r\n\r\n    cup = Coffee.new\r\n    cup.brew\r\n    cup.strategy.should == 'normal'\r\n\r\n\r\n    injector :sweedish do\r\n    \tdef brew\r\n    \t\t@strategy = 'sweedish'\r\n    \tend\r\n    end\r\n\r\n    cup = Coffee.new.enrich(sweedish)             # clobbers original strategy for this instance only!!\r\n    cup.brew\r\n    cup.strategy.should == ('sweedish')\r\n\r\n\r\nBut, with #eject it is possible to have an even more general alternate implementation. This time we completely replace the current strategy by actually ejecting it out of the class and then injecting a new one:\r\n\r\n    class Tea < Coffee  # Tea is a type of coffee!! ;~Q)\r\n    \tinjector :SpecialStrategy do\r\n    \t\tdef brew\r\n    \t\t\t@strategy = 'special'\r\n    \t\tend\r\n    \tend\r\n    \tinject SpecialStrategy()\r\n    end\r\n\r\n    cup = Tea.new\r\n    cup.brew\r\n    cup.strategy.should == 'special'\r\n\r\n    Tea.eject :SpecialStrategy\r\n\r\n    Tea.inject sweedish\r\n\r\n    cup.brew\r\n    cup.strategy.should == 'sweedish'\r\n\r\n\t\r\n### Injector Directives\r\nOnce you have an injector handle you can also use it to issue directives to the injector.  These directives can have a profound effect on your code.\r\n\r\n#### :collapse directive\r\nThis description produces similar results to the previous except that further injector method calls DO NOT raise an error.  They just quietly return nil. Here are a couple of different cases:\r\n\r\nThe case with multiple objects\r\n\r\n  \tinjector :copiable do\r\n  \t\tdef object_copy\r\n  \t\t\t'a dubious copy'\r\n  \t\tend\r\n  \tend\r\n\r\n  \to1 = Object.new.enrich(copiable)\r\n  \to2 = Object.new.enrich(copiable)\r\n\r\n  \to1.object_copy.should == 'a dubious copy'\r\n  \to2.object_copy.should == 'a dubious copy'\r\n\r\n  \tcopiable :silence\r\n\r\n  \to1.object_copy.should == nil\r\n  \to2.object_copy.should == nil\r\n\r\n\r\nThe case with a class receiver:\r\n\r\n  \tclass SomeClass\r\n  \t\tinjector :code do\r\n  \t\t\tdef tester\r\n  \t\t\t\t'boo'\r\n  \t\t\tend\r\n  \t\tend\r\n\r\n  \t\tinject code\r\n  \tend\r\n\r\n  \t# collapse\r\n  \tSomeClass.code :collapse\r\n\r\n  \t# build\r\n  \ta = SomeClass.new\r\n  \tb = SomeClass.new\r\n\r\n  \ta.tester.should == nil\r\n  \tb.tester.should == nil\r\n\r\n  \t# further\r\n  \tSomeClass.eject :code \r\n  \texpect{ a.tester }.to raise_error\r\n  \texpect{ b.tester }.to raise_error\r\n\r\n\r\n\r\n#### :rebuild directive\r\nInjectors that have been collapsed can at a later point then be reconstituted.  Here are a couple of cases:\r\n\r\nThe case with multiple object receivers:\r\n\r\n    injector :reenforcer do\r\n    \tdef thick_walls\r\n    \t\t'=====  ====='\r\n    \tend\r\n    end\r\n\r\n    o1 = Object.new.enrich(reenforcer)\r\n    o2 = Object.new.enrich(reenforcer)\r\n\r\n    reenforcer :collapse\r\n\r\n    o1.thick_walls.should == nil\r\n    o2.thick_walls.should == nil\r\n\r\n    reenforcer :rebuild\r\n\r\n    o1.thick_walls.should == '=====  ====='\r\n    o2.thick_walls.should == '=====  ====='\r\n\r\n\r\nThe case with a class receiver:\r\n\r\n  \tclass SomeBloatedObject\r\n  \t\tinjector :ThinFunction do\r\n  \t\t\tdef perform\r\n  \t\t\t\t'do the deed'\r\n  \t\t\tend\r\n  \t\tend\r\n  \t\tinject ThinFunction()\r\n  \tend\r\n  \tSomeBloatedObject.ThinFunction :silence\r\n\r\n  \ttester = SomeBloatedObject.new\r\n  \ttester.perform.should == nil\r\n\r\n  \tSomeBloatedObject.ThinFunction :active\r\n  \ttester.perform.should == 'do the deed'\r\n  \t\r\n  \t\r\n#### :implode directive\r\nThis directive totally destroys the injector including the handle to it.  Use it carefully!\r\n\r\nFor more information and additional examples see the rspec examples on this project.  There you'll find a long list of rspec example code showcasing some additional features of Jackbox Injectors along with some additional descriptions.\r\n\r\n\r\n## Additional Tools\r\nJackbox includes a couple of additional ancillary tools.  The first is an Abstract class base that prevents instantiation of the base class itself but not of its descendants.  The second is a persistent properties module named Prefs; it creates class/module/namespace level persistent properties.\r\n\r\nWith Abstract the code goes like this:\r\n\r\n    class Vector\r\n    \textend Abstract\r\n    \tdef speed\r\n    \t  0\r\n    \tend\r\n    \tdef direction\r\n    \tend\r\n    end\r\n    expect{Vector.new}.to raise_error\r\n    \r\n    class Velocity < Vector\r\n    \tdef speed\r\n    \t  super + 35\r\n    \tend\r\n    \tdef direction\r\n          :north\r\n    \tend\r\n    end\r\n    \r\n    expect{Velocity.new}.to_not raise_error\r\n    Velocity.new.speed.should == 35\r\n\r\n\r\nWith Prefs you can add persistent properties to a class.  These properties persist even through program termination. Here is the example code:\r\n\r\n    module Jester\r\n    \textend Prefs\r\n\t\r\n    \tpref :value => 10\r\n    end\r\n    \r\n    Jester.value.should == 10\r\n    Jester.value = 3\r\n    Jester.value.should == 3\r\n    Jester.reset :value\r\n    Jester.value.should == 10 \r\n  \r\nThere is also command line utility called **jackup** that simply allows users to bring their projects into a *\"Jackbox level\"*.  It inserts the right references and turns the targeted project into a bundler gem if it isn't already one also adding a couple of rake tasks.\r\n\r\n## Availability\r\n\r\nJackbox is current available for Linux, Mac, and Windows versions of Ruby 1.9.3 thru 2.1.1\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n    gem 'jackbox'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install jackbox\r\n    \r\nAnd then execute the following command inside the project directory:\r\n\r\n    $jackup \r\n    \r\n\r\n\r\n## Support\r\nAny questions/suggestions can be directed to the following email address: \r\n\r\n__service.delivered@ymail.com__.  \r\n\r\nPlease include your platform along with a description of the problem and any available stack trace.  Please keep in mind that, at this time we have limited staff and we will do our best to have a quick response time.\r\n\r\n## Licensing\r\n\r\nJackbox is currently free for anyone to **use**.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\nNON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\nCopyright © 2014 LHA. All rights reserved.","google":"UA-58877141-2","note":"Don't delete this file! It's used internally to help with page regeneration."}