{"name":"Jackbox","tagline":"Modular Closures: Ruby Code Injectors","body":"<!---\r\n# @author Lou Henry Alvarez\r\n-->\r\nCopyright © 2014, 2015 LHA. All rights reserved.\r\n\r\nJackbox   <a href=\"https://plus.google.com/102732809517976898938\" rel=\"publisher\">Google+</a>\r\n=======\r\n\r\nThe main library function at this time centers around the concept of code Injectors.  To make it easier to grasp the idea behind them, these can perhaps be thought of as a form of **closures which can also serve as modules**.  Most of all Injectors propose some additional interesting properties to the idea of a mix-in.  For instance, they give your code the ability to capture its surrounding context and mix it into an indiscriminate target.  They make it possible to solve several general problems in some areas of OOP, overcoming traditional Ruby shortcomings with the GOF Decorator and Strategy Patterns, and enabling **some new code patterns.**  They instrument control over (code presence) the presence of injector code in targets with mechanisms involving injector ejection and directives.  They extend Ruby's mix-in and method resolution over and beyond what is possible with regular modules. Finally, they introduce the concept of Injector Versioning.  This is a feature which allows you to redefine parts of your program in local isolation and without it affecting others.  See Injector Versioning below.  \r\n\r\nBasic Methods\r\n--------------------------\r\nThere are some basic Jackbox methods.  The are just rudimentary helpers, which in effect are a form of syntax sugar for every day things.  Their descriptions follow:\r\n\r\n#### #decorate :sym, &blk \r\nThis method allows for decorations to be placed on a single method, be it an instance or class method without too much fuss. One important thing about #decorate is that it works like #define_method, but in addition, it also makes possible the use of Ruby's #super within the body of the decorator.  It really presents a better alternative and can be used instead of #alias\\_method\\_chain.\r\n\r\nAt the class level:\r\n\r\n    class One\r\n      decorate :foo do\r\n        super() + 'decoration '                   # super available within decoration\r\n      end\r\n    end\r\n\r\n    One.new.foo\r\n    #=> foo decoration\r\n\r\nOr, at the object level:\r\n\r\n    one = One.new\r\n\r\n    one.decorate :foo do |arg|\r\n      super() + arg                               # again the use of super is possible\r\n    end\r\n\r\n    one.foo('after')\r\n    #=> foo decoration after\r\n\r\nIt also works like so:\r\n\r\n    Object.decorate :inspect do\r\n      puts super() + \" is your object\"\r\n    end\r\n\r\n    Object.new.inspect\r\n    #=> #<Object:0x00000101787e20> is your object\r\n\r\n\r\n#### #with obj, &blk \r\nThere is also a new version of the :with construct.  The important thing to remember about #with is it has a primary context which is the object passed to it, and a secondary context which is the object you are making the call from.  This allows you to work **with** both contexts at the same time. The other important thing about #with is that it allows you to directly place definitions on and returns the same object you passed into it. \r\n\r\nHere is some sample usage code:\r\n\r\n    class One\r\n      def foo(arg)\r\n        'in One ' + arg\r\n      end\r\n    end\r\n\r\n    class Two\r\n      def faa(arg)\r\n        'and in Two ' + arg\r\n      end\r\n      def meth\r\n        with One.new do                           # context of One and Two available simultaneously!!!\r\n          return foo faa 'with something'         \r\n        end                                       # return object\r\n      end\r\n    end\r\n\r\n    Two.new.meth\r\n    #=> 'in One and in Two with something'\r\n\r\nUse it to define function:\r\n\r\n    # internal facade for Marshal\r\n    with Object.new do\r\n\r\n    \t@file_spec = [file, mode]\t\t\t\t\r\n    \tdef dump hash\r\n    \t\tFile.open(*@file_spec) do |file|\r\n    \t\t\tMarshal.dump( hash, file)\r\n    \t\tend\r\n    \tend\r\n    \tdef load hash\r\n    \t\tFile.open(*@file_spec) do |file|\r\n    \t\t\thash.merge!(Marshal.load( file ))\r\n    \t\tend\r\n    \tend\r\n\r\n    end\r\n\r\nUse it with **#decorate** on singleton classes like this:\r\n\r\n    class Dir\r\n\r\n      with singleton_class do\r\n        decorate :entries do |name='.', opts=nil| #:doc:\r\n          super name, opts\r\n        end\r\n        decorate :new do |name, &code| #:doc:\r\n          FileUtils.mkpath name unless exists?(name)\r\n          return Dir.open(name, &code) if code\r\n          Dir.open name\r\n        end\r\n      end\r\n\r\n    end\r\n\r\n    \r\n#### #lets sym=nil, &blk \r\nThis is simple syntax sugar.  It allows the creation of local or global procs using a more function-like syntax.  It adds readability to some constructs.  Here are some examples:\r\n\r\nTo define local functions/lambdas. Define symbols in local scope:\r\n\r\n    def main\r\n      lets bar =->(arg){ arg * arg }              # read as lets set bar to lambda/proc \r\n\r\n      # later on ...\r\n\r\n      var = bar[3]                                # bar is only available within #main\r\n      #...\r\n    end\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\r\nAs a shortcut for define_method. Use it for short functional definitions:\r\n\r\n    lets( :meth ){ |arg| arg * 2 }                # read as lets define symbol :meth to be ....\r\n    meth(3)\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n    # => 6 \r\n\r\nCan be used to define a special values or pseudo-immutable strings:\r\n\r\n    lets(:foo){ 3+Math::Pi }                      # read as lets set :foo to value\r\n    lets(:faa){ 'some important string' }\r\n    \r\n\r\nInjectors\r\n----------\r\nInjectors are the main tool in Jackbox at the time of this writing. These again are a form of mix-in that has properties of both a closure and a module.  They can also be thought of as an **extended closure** if you will or as a special kind of module if you want.  In the sections below we will discuss some of the methods available to you with Jackbox in connection with Injectors, as well as elaborate on some of the other properties of injectors. But, it is essential to understand there are some syntactical differences to Injectors with respect to regular modules.  We will show them first, with some examples: \r\n\r\n**INJECTORS ARE DECLARED IN THE FOLLOWING WAYS:**\r\n\r\n\r\n    injector :name\r\n\r\n    #  or...\r\n\r\n    Name = injector :name\r\n\r\n    # or even ...\r\n\r\n    jack :Name                                    # capitalized method, using alias #jack \r\n    slot :name                                    # also alias to slot\r\n\r\n\r\nTheir use and semantics are somewhat defined by the following snippet.  But, to fully understand their implications to your code, you have to understand the sections on injector versioning, their behavior under inheritance, and perhaps injector directives. \r\n\r\n    # somewhere in your code\r\n    include Injectors\r\n\r\n    injector :my_injector                         # define the injector \r\n    \r\n    my_injector do                     \r\n      def bar                  \r\n        :a_bar\r\n      end\r\n    end\r\n\r\n    # later on...\r\n    widget.enrich my_injector                     # apply the injector\r\n    widget.bar\r\n    # => bar\r\n    \r\n    # or...  \r\n    \r\n    Mine = my_injector\r\n    class Target\r\n      inject Mine                                 # apply the injector\r\n    end\r\n    \r\n    Target.new.bar\r\n    # => bar\r\n    \r\n    # etc ...\r\n\r\nHere is a more interesting example:\r\n\r\n    class ClosureExpose\r\n\r\n    \tsome_value = 'something'\r\n\r\n    \tinjector :capture do\r\n    \t\tdefine_method :val do\r\n    \t\t\tsome_value\r\n    \t\tend\r\n    \tend\r\n    end\r\n\r\n    class SecondClass\r\n    \tinject ClosureExpose.capture\r\n    end\r\n\r\n    # the result\r\n    SecondClass.new.val.should == 'something'\r\n\r\n**INJECTORS HAVE PROLONGATIONS:**\r\n\r\n    injector :my_injector\r\n\r\n    my_injector do                                # first prolongation\r\n\r\n      def another_method\r\n      end\r\n\r\n    end\r\n\r\n    # ...\r\n\r\n    my_injector do                                # another prolongation\r\n\r\n      def yet_another_method\r\n      end\r\n\r\n    end\r\n\r\n#### #injector :sym\r\nThis is a global function.  It defines an object of type Injector with the name of symbol.  Use it when you want to generate an Injector object for later use.  The symbol can then be used as a handle to the injector whenever you need to prolong the injector by adding methods to it or apply it to another object. Additionally, this symbol plays a role in defining the injector's scope.  Injectors with capitalized names like :Function, :Style, etc have a global scope.  That is they are available throughout the program:\r\n\r\n    class A\r\n      injector :Function\r\n    end\r\n\r\n    class B\r\n      include Function()\r\n    end\r\n\r\n    # This is perfectly valid with injectors  \r\n\r\nOn the other hand Injectors with a lower case name are only available __from__ the scope in which they were defined, like the following example shows:\r\n\r\n    class AA\r\n      injector :form\r\n    end\r\n\r\n    class BB\r\n      include form                                # This genenerates and ERROR!                                 \r\n    end                         \r\n                      \r\n    class BB\r\n      include AA.form\r\n    end\r\n\r\n    # This is perfectly valid with injectors  \r\n\r\nFor all this to happen Jackbox also introduces some additional Ruby constructs, namely the keywords #inject and #enrich.  These can be thought as simply new corollaries to #include and #extend. In fact they can be used interchangeably.  If you're working with injectors you may want to use them instead depending on context to make clear your intent.\r\n\r\n#### #include/inject *jack\r\nThis method is analogous to ruby's #include but its use is reserved for Injectors.  The scope of this method is the same as the scope of #include, and its intended use like include's is for class definitions. Use it to \"include\" an Injector into a receiving class.  Takes multiple injectors.\r\n\r\n#### #extend/enrich *jack\r\nThis method in turn is analogous to ruby's #extend. The scope of this method is also the same as that of #extend, and its intended use if for object definition.  Use it to extend the receiver of an injector.  Takes multiple injectors.\r\n\r\n**IMPORTANT NOTE: Injector lookup follows the method and not the constant lookup algorithm.**\r\n\r\nIf you need to follow constant lookup, here is the code for that:\r\n\r\n    Name = injector :sym ....                     # this also creates a hard tag (see below)\r\n\r\n### Injector Versioning\r\n\r\nOne of the most valuable properties of injectors is Injector Versioning.  Versioning is the term used to identify a feature in the code that produces an artifact of injection which contains a certain set of methods with their associated outputs, and represents a snapshot of that injector up until the point it's applied to an object.  From, that point on the object contains only that version of methods from that injector, and any subsequent overrides to those methods are only members of the \"prolongation\" of the injector and do not become part of the object of injection unless some form of re-injection occurs. Newer versions of an injector's methods only become part of newer objects or newer injections into existing targets.  With Jackbox Injector Versioning two different versions of the same code object can be running simultaneously. \r\n\r\nWe'll use some examples to illustrate the point.  This is how versioning occurs:\r\n\r\n    # injector declaration\r\n    #___________________\r\n    injector :my_injector do \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n      def bar\r\n        :a_bar                                    # version bar.1\r\n      end\r\n      def foo\r\n      \t# ...\r\n      end\r\n    end\r\n\r\n    object1.enrich my_injector                    # apply the injector --first snapshot\r\n    object1.bar.should == :a_bar                  # pass the test\r\n\r\n    # injector prolongation\r\n    #__________________\r\n    my_injector do \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n      def bar\r\n        :some_larger_bar                          # version bar.2 ... re-defines bar\r\n      end\r\n      # ...\r\n    end\r\n    \r\n    object2.enrich my_injector                    # apply the injector --second snapshot\r\n    object2.bar.should == :some_larger_bar\r\n\r\n    # result\r\n    \r\n    object1.bar.should == :a_bar                  # bar.1 is still the one\r\n\r\n    ###############################################\r\n    # First object has kept its preferred version #\r\n    ###############################################\r\n\r\n\r\nWhen re-injection occurs, and only then does the new version of the #bar method come into play. But the object remains unaffected otherwise, keeping its preferred version of methods.  The new version is available for further injections down the line and to newer client code.  Internal local-binding is preserved.  If re-injection is executed then clients of the previous version get updated with the newer one.  Here is the code:\r\n\r\n    # re-injection\r\n    #_________________\r\n    object1.enrich my_injector                    # re-injection --third snapshot\r\n\r\n    object1.bar.should == :some_larger_bar        # bar.2 now available\r\n\r\n    ###############################################\r\n    # First object now has the updated version    #\r\n    ###############################################\r\n\r\n\r\nRe-injection on classes is a little bit trickier.  Why? Because class injection should be more pervasive --we don't necessarily want to be redefining a class at every step. To re-inject a class we must use the Strategy Pattern (see below) or use a private update.  See the sections below as well as the rspec files for more on this.   \r\n\r\nHere is an example of Injector Versioning as it pertains to classes:\r\n\r\n    # injector declaration:\r\n    #___________________\r\n    injector :Versions do\r\n      def meth arg                                # version meth.1\r\n        arg ** arg\r\n      end\r\n    end\r\n\r\n    class One\r\n      inject Versions()                           # apply --snapshot\r\n    end\r\n\r\n    # injector prolongation:                              \r\n    #_________________\r\n    Versions do\r\n      def meth arg1, arg2                         # version meth.2 ... redefines meth.1\r\n        arg1 * arg2\r\n      end\r\n    end\r\n\r\n    class Two\r\n      inject Versions()                           # apply --snapshot\r\n    end\r\n\r\n    # result\r\n\r\n    Two.new.meth(2,4).should == 8                 # meth.2 \r\n    One.new.meth(3).should == 27                  # meth.1\r\n\r\n    ##############################################\r\n    # Two different injector versions coexisting #\r\n    ##############################################\r\n\r\nTo update the class, we then do the following:\r\n    \r\n    class One\r\n      update Versions()                           # private call to #update\r\n    end\r\n    \r\n    One.new.meth(2,4).should == 8                 # meth.2 \r\n    Two.new.meth(2,4).should == 8                 # meth.2 \r\n\r\n    ##############################################\r\n    # class One is now updated to the latest     #\r\n    ##############################################\r\n    \r\n\r\n### Tagging/Naming\r\n\r\nThe use of Tags is central to the concept of Injector Versioning.  Tagging happens in the following ways:\r\n\r\n    Version1 = jack :function do\r\n      def meth arg\r\n        arg\r\n      end\r\n      def mith\r\n        meth 2\r\n      end\r\n    end\r\n\r\n    Version2 = function do\r\n      def mith arg\r\n        meth(arg) * meth(arg)\r\n      end\r\n    end\r\n\r\nVersion1 and Version2 are two different hard versions/tags/names of the same Injector.  There are also soft tags (see below).  \r\n\r\n### Local Binding\r\n\r\nBefore we move on, we also want to give some further treatment to injector local-binding.  That is, the binding of an injectors' methods is local to the prolongation/version in which they are located before the versioning occurs.  Here, is the code:\r\n\r\n**Note: In the following examples we use the notion of version naming/tagging.  This allows you to tag different versions/prolongations of an Injector for later use.  Once a version is tagged it shouldn't be modified**\r\n                                                          \r\n\r\n    # injector declaration\r\n    #_____________________\r\n\r\n    Version1 = injector :functionality do\r\n      def basic arg                               # version basic.1\r\n        arg * 2\r\n      end\r\n    end\r\n    \r\n    o = Object.new.enrich Version1                # apply --snapshot (like above)\r\n    o.basic(1).should == 2                        # basic.1 \r\n\r\n    # injector prolongation\r\n    #_____________________\r\n\r\n    Version2 = functionality do\r\n      def basic arg                               # version basic.2\r\n        arg * 3                                   # specific use in compound.1\r\n      end\r\n\r\n      def compound                                # compound.1 \r\n        basic(3) + 2                                      \r\n      end\r\n    end\r\n                                               \r\n    p = Object.new.enrich Version2                # apply --snapshot (like above)\r\n    p.basic(1).should == 3                        # basic.2 \r\n    p.compound.should == 11                       # compound.1 --bound locally to basic.2\r\n    \r\n    o.basic(1).should == 2                        # basic.1 \r\n    o.compound.should == 11                       # compound.1 --bound locally to basic.2\r\n    \r\n    ####################################################\r\n    # #compound.1 bound to the right version #basic.2  #\r\n    ####################################################\r\n    \r\n    \r\n#### #define\\_method sym, &blk\r\nThere is one more interesting property to method definition on Injectors however. The use of #define\\_method to re-define methods in any prolongation updates the entire injector and all its versions.  This also preserves a fundamental tenet of injectors: take some local context, enclose it, and use the injector to introduce it to some indiscriminate target, and additionally has some other uses as we'll see with in our description of patterns and injector composition.  \r\n\r\nHere is an example of the difference with #define\\_method:\r\n\r\n    jack :some_jack do\r\n    \tdef meth\r\n    \t  :meth\r\n    \tend\r\n    \t\r\n    \tdef foo_bar\r\n    \t\t'a foo and a bar'\r\n    \tend\r\n    end\r\n\r\n    class Client\r\n    \tinject some_jack\r\n    end\r\n\r\n    Client.new.meth.should == :meth\r\n    Client.new.foo_bar.should == 'a foo and a bar'      \r\n\r\n\r\n    some_jack do                                  \r\n    \tdef meth                                    # New version\r\n    \t  puts :them\r\n    \tend\r\n    \t\r\n    \tdefine_method :foo_bar do                   # New version\r\n    \t\t'fooooo and barrrrr'\r\n    \tend\r\n    end     \r\n                                                  ################################\r\n                                                  # Like above!                  #\r\n    Client.new.meth.should == :meth               # No re-injection == No change #\r\n                                                  ################################\r\n    \r\n                                                  ################################\r\n    Client.new.foo_bar.should ==                  # Different!!!                 #\r\n    'fooooo and barrrrr'                          # No re-injection == Change    #\r\n                                                  # . Thanks to define_method    #\r\n                                                  ################################ \r\n\r\nInjector Versioning together with injector local-binding allow the metamorphosis of injectors to fit the particular purpose at hand and keeping those local modifications isolated from the rest of your program making your code to naturally evolve with your program. Use it as an alternative to refinements.\r\n\r\n### Injector introspection\r\nInjectors have the ability to speak about themselves.  Moreover injectors can speak about their members just like any module or class, and can also inject their receivers with these introspecting capabilities.  Every injected/enriched object or module/class can enumerate its injectors, and injectors can enumerate their members, and so forth.  \r\n    \r\n    injector :Function do\r\n      def far\r\n      end\r\n      def close\r\n      end\r\n    end\r\n    \r\n    injector :Style do\r\n    \tdef pretty\r\n    \tend\r\n    end\r\n\r\n    class Target\r\n      inject Function(), Style()\r\n    end\r\n\r\n    # class ?\r\n    \r\n    Function().class.should == Injector                 \r\n    Style().class.should == Injector \r\n    \r\n#### #injectors *sym\r\nCalled with no arguments returns a list of injectors.  A call with a list of injector symbols however returns an array of actual Injector objects matching the names supplied in a LIFO fashion. An example use goes like this:\r\n\r\n    # injectors (in this target) ?\r\n    \r\n    Target.injectors \r\n    => [(#944120:|Function|), (#942460:|Style|)] \r\n    \r\n    # injectors :name ?\r\n    \r\n    Target.injectors :Function\r\n     => [(#944120:|Function|)]                    # same as #injectors.collect_by_name :name\r\n     \r\n    Target.injectors :all                         # all injectors in this class's hierarchy \r\n                                                  (see section on Inheritance)\r\n     \r\nThe method also extends into a minuscule API: \r\n    \r\n    Target.injectors.by_name.should == [:Function, :Style] \r\n    # ...\r\n    Target.injectors(:all).by_name\r\n    # aliased to :sym_list\r\n    \r\n    Target.injectors.collect_by_name :name        # see above\r\n    # ...\r\n    Target.injectors(:all).collect_by_name :name\r\n    # aliased to :all_by_sym\r\n    \r\n    Target.injectors.find_by_name :Function       # last one in first out\r\n     => (#944120:|Function|)      \r\n    # ...\r\n    Target.injectors(:all).find_by_name :name\r\n    # aliased to last_by_sym\r\n    \r\n    Function().instance_methods.should == [:far, :close]      \r\n    Style().instance_methods.should == [:pretty]    \r\n\r\n    # later on...\r\n\r\n    # eject all injectors in target\r\n    Target.injectors.each{ |j| Target.eject j }\r\n    \r\n    # or..\r\n    \r\n    Target.eject *Target.injectors       \r\n\r\n\r\n### Injector composition\r\nThe composition of multiple injectors into an object can be specified as follows:\r\n\r\n    include Injectors\r\n    \r\n    # declare injectors\r\n    injector :FuelSystem                          # capitalized methods\r\n    injector :Engines\r\n    injector :Capsule\r\n    injector :Landing\r\n\r\n    # compose the object\r\n    class SpaceShip\r\n    \r\n    \tinject FuelSystem(), Engines(), Capsule(), Langing()    # capitalized method use\r\n\r\n    \tdef launch\r\n    \t\tgas_tank fuel_lines burners ignition :go\r\n    \t\tself\r\n    \tend\r\n    end\r\n    \r\n    Spaceship.injectors.by_name == [:FuelSystem, :Engines, :Capsule, :Landing]\r\n\r\n    # define functionality\r\n    FuelSystem do\r\n    \tdef gas_tank arg\r\n    \t\t:gas\r\n    \tend\r\n    \tdef fuel_lines arg\r\n    \t\t:fuel\r\n    \tend\r\n    \tdef burners arg\r\n    \t\t:metal\r\n    \tend\r\n    end\r\n\r\n    # ...\r\n    \r\n    # create object\r\n    flyer = SpaceShip.new.launch\r\n\r\n\r\n    # in-flight definitions, ha ha ha\r\n    var = 'wheels'\r\n    \r\n    Landing do\r\n    \tdefine_method :gear do                      # a clolsure !!\r\n    \t\tvar\r\n    \tend\r\n    end\r\n\r\n### Inheritance\r\nThe behavior of Injectors under inheritance is partially specified by what follows:\r\n\r\n    injector :j\r\n    \r\n    class C\r\n    end\r\n    C.inject j {                                  #foo pre-defined at time of injection\r\n      def foo\r\n        'foo'\r\n      end\r\n    }\r\n    C.injectors.by_name.should == [:j]\r\n    C.new.injectors.by_name.should == [:j]\r\n\r\n    C.new.foo.should == 'foo'\r\n\r\n    # D inherits from C\r\n\r\n    class D < C                                   # methods are inherited from j \r\n    end\r\n    D.injectors.by_name.should == []\r\n    D.injectors(:all).by_name == [:j]\r\n\r\n    # New Objects\r\n    C.new.foo.should == 'foo'\t\t\t\t\t\t\t\t\t\t\t\r\n    D.new.foo.should == 'foo'\r\n\r\n\r\nMore importantly though is the following:\r\n\r\n    slot :player do                       \r\n    \tdef sound                               \r\n    \t\t'Lets make some music'                \r\n    \tend                                     \r\n    end                                       \r\n\r\n    TapePlayer = player do                        # version Tag\r\n    \tdef play                                      # inherirts :sound\r\n    \t\treturn 'Tape playing...' + sound()                          \r\n    \tend                                     \r\n    end                                       \r\n\r\n    CDPlayer = player do                          # another version Tag\r\n    \tdef play                                      # also inherits sound\r\n    \t\treturn 'CD playing...' + sound()\r\n    \tend\r\n    end\r\n\r\n    class BoomBox\r\n    \tinclude TapePlayer\r\n\r\n    \tdef on\r\n    \t\tplay\r\n    \tend\r\n    end\r\n\r\n    class JukeBox < BoomBox                       # regular class inheritance\r\n    \tinject CDPlayer\r\n    end\r\n\r\n    BoomBox.new.on.should == 'Tape playing...Lets make some music'\r\n    JukeBox.new.on.should == 'CD playing...Lets make some music'\r\n    \r\n    jack :speakers\r\n\r\n    Bass = speakers do                            # adding composition   \r\n    \tdef sound                               \r\n    \t\tsuper + '...boom boom boom...'        \r\n    \tend                                     \r\n    end                                       \r\n    JukeBox.inject Bass\r\n\r\n    JukeBox.new.on.should == 'CD playing...Lets make some music...boom boom boom...'\r\n    \r\nFrom all this, the important thing to take is that injectors provide a sort of versioned inheritance.  The version inherits all of the pre-existing methods from the injector and freezes that function.  We can either Tag/Name it of simply include/extend into a target but the function is frozen at that time.  Tags cannot be modified or more clearly shouldn't be modified.  Classes retain the frozen version of the injector until the time an update is made.  Of course, there is always #define\\_method.   For more on all this see, the Rspec examples.\r\n\r\n\r\n---\r\nBut, this is the basic idea here.  An extended closure which can be used as a mix-in, prolonged to add function, and versioned and renamed to fit the purpose at hand. \r\n\r\n---\r\nUsing this approach Jackbox also goes on to solve the Decorator Pattern problem in the Ruby language.  \r\n\r\n### The GOF Decorator Pattern:   \r\nTraditionally this is only partially solved in Ruby through PORO decorators or the use of modules.  However, there are the problems of loss of class identity for the former and the limitations on the times it can be re-applied to the same object for the latter. With Jackbox this is solved.  An injector used as a decorator does not confuse class identity for the receiver. Decorators are useful in several areas of OOP: presentation layers, stream processing, command processors to name a few.  \r\n\r\nHere is the code for that:\r\n\r\n\tclass Coffee\r\n\t\tdef cost\r\n\t\t\t1.50\r\n\t\tend\r\n\tend\r\n\r\n\tinjector :milk do\r\n\t\tdef cost\r\n\t\t\tsuper() + 0.30\r\n\t\tend\r\n\tend\r\n\tinjector :vanilla do\r\n\t\tdef cost\r\n\t\t\tsuper() + 0.15\r\n\t\tend\r\n\tend\r\n\t\r\n\tcup = Coffee.new.enrich(milk).enrich(vanilla)\r\n\tcup.should be_instance_of(Coffee)\r\n\r\n\tcup.cost.should == 1.95\r\n\r\n\r\nFurthermore, these same decorators can be then re-applied MULTIPLE TIMES to the same receiver.  This is something that is normally not possible with the regular Ruby base language.  Here are further examples:\r\n\r\n\tcup = Coffee.new.enrich(milk).enrich(vanilla).enrich(vanilla)\r\n\t\r\n\t# or even...\r\n\t\r\n\tcup = Coffee.new.enrich milk, vanilla, vanilla\r\n\r\n\tcup.cost.should == 2.10\r\n\tcup.should be_instance_of(Coffee)\r\n\tcup.injectors.should == [:milk, :vanilla, :vanilla]\r\n\r\n\t\r\n### Other Capabilities of Injectors\r\n\r\nThe functionality of an injector can be removed after an #enrich to individual objects:\r\n\t\r\n  \tclass Coffee\r\n  \t\tdef cost\r\n  \t\t\t1.00\r\n  \t\tend\r\n  \tend\r\n  \tinjector :milk do\r\n  \t\tdef cost\r\n  \t\t\tsuper() + 0.50\r\n  \t\tend\r\n  \tend\r\n\r\n  \tcup = Coffee.new.enrich(milk)\r\n  \tfriends_cup = Coffee.new.enrich(milk)\r\n\r\n  \tcup.cost.should == 1.50\r\n  \tfriends_cup.cost.should == 1.50\r\n\r\n  \tcup.eject :milk\r\n  \t\r\n  \tcup.cost.should == 1.00\r\n  \t\r\n  \t# friends cup didn't change price\r\n  \tfriends_cup.cost.should == 1.50\r\n  \t\r\nOr, removed after an #inject at the class level:\r\n\r\n    # create the injection\r\n    class Home\r\n    \tinjector :layout do\r\n    \t\tdef fractal\r\n    \t\tend\r\n    \tend\r\n    \tinject layout\r\n    end\r\n    expect{Home.new.fractal}.to_not raise_error\r\n\r\n    # build\r\n    my_home = Home.new\r\n    friends = Home.new\r\n\r\n    # eject the code\r\n    class Home\r\n    \teject :layout\r\n    end\r\n\r\n    # the result\r\n    expect{my_home.fractal}.to raise_error\r\n    expect{friends.fractal}.to raise_error\r\n    expect{Home.new.fractal}.to raise_error\r\n\r\n\t\r\nThe code for this makes use of :eject which is also part of Jackbox and opens the door to some additional functionality provided by injectors.  This additional function allows Injectors to be truly used to inject and eject code at will.\r\n\r\n#### :eject *sym\r\nThis method ejects injector function from a single object or class.  For other forms of injector withdrawal see the next sections.  It is in scope on any classes injected or enriched by an injector.  For more on this see the rspec examples.\r\n\r\n### The GOF Strategy Pattern:\r\nAnother pattern that Jackbox helps with is the GOF Strategy Pattern.  This is a pattern with changes the guts of an object as opposed to just changing its face. Traditional examples of this pattern use PORO component injection within constructors. \r\n\r\nHere are a couple alternate implementations:\r\n\r\n    class Coffee\r\n    \tattr_reader :strategy\r\n\r\n    \tdef initialize\r\n    \t  @strategy = nil\r\n    \tend\r\n    \tdef cost\r\n    \t\t1.00\r\n    \tend\r\n      def brew\r\n    \t\t@strategy = 'normal'\r\n      end\r\n    end\r\n\r\n    cup = Coffee.new\r\n    cup.brew\r\n    cup.strategy.should == 'normal'\r\n\r\n\r\n    injector :sweedish do\r\n    \tdef brew\r\n    \t\t@strategy = 'sweedish'\r\n    \tend\r\n    end\r\n\r\n    cup = Coffee.new.enrich(sweedish)           # clobbers original strategy for this instance only!!\r\n    cup.brew\r\n    cup.strategy.should == ('sweedish')\r\n\r\n\r\nBut, with #eject it is possible to have an even more general alternate implementation. This time we completely replace the current strategy by actually ejecting it out of the class and then injecting a new one:\r\n\r\n    class Tea < Coffee  # Tea is a type of coffee!! ;~Q)\r\n    \tinjector :SpecialStrategy do\r\n    \t\tdef brew\r\n    \t\t\t@strategy = 'special'\r\n    \t\tend\r\n    \tend\r\n    \tinject SpecialStrategy()\r\n    end\r\n\r\n    cup = Tea.new\r\n    cup.brew\r\n    cup.strategy.should == 'special'\r\n\r\n    Tea.eject :SpecialStrategy\r\n\r\n    Tea.inject sweedish\r\n\r\n    cup.brew\r\n    cup.strategy.should == 'sweedish'\r\n\r\n### Soft Tags\r\nJust like hard tags above but a name is not needed:\r\n\r\n    jack :SomeJack do\r\n      def foo\r\n        :foo\r\n      end\r\n    end\r\n\r\n    SomeJack(:tag) do                             # New Version, not named\r\n      def foo\r\n        :foooooooo\r\n      end\r\n    end\r\n\r\n\r\n### Patterns of a Different Flavor\r\n\r\nThere are some additional patterns possible with Jackbox Injectors:\r\n\r\n__1) Late Decorator.-__ Another flow that also benefits from #define\\_method in an interesting way is the following:   \r\n\r\n    class Widget\r\n    \tdef cost\r\n    \t\t1\r\n    \tend\r\n    end\r\n    w = Widget.new\r\n\r\n    injector :decorator\r\n\r\n    w.enrich decorator, decorator, decorator, decorator\r\n\r\n    # user input\r\n    bid = 3.5 \r\n\r\n    decorator do\r\n    \tdefine_method :cost do                      # defines function on all injectors of the class\r\n    \t\tsuper() + bid\r\n    \tend\r\n    end\r\n\r\n    w.cost.should == 15\r\n\r\nThe actual injector function is late bound and defined only after some other data is available.\r\n\r\n__2) The Super Pattern.-__ No.  This is not a superlative kind of pattern.  Simply, the use of #super can be harnessed into a pattern of controlled recursion, like in the following example: \r\n\r\n    jack :Superb\r\n\r\n    Superb do\r\n    \tdef process string, additives, index\r\n    \t\tstr = string.gsub('o', additives.slice!(index))\r\n    \t\tsuper(string, additives, index) + str rescue str\r\n    \tend\r\n    \textend Superb(), Superb(), Superb()\r\n    end   \r\n\r\n    Superb().process( 'food ', 'aeiu', 0 ).should == 'fuud fiid feed faad '\r\n    Superb(:implode)                                 \r\n\r\n__3) The Transformer Pattern.-__  For a specific example of what can be accomplished using this workflow please refer to the rspec directory under the transformers spec.  Here is the basic flow:\r\n\r\n    jack :Solution\r\n\r\n    Solution( :tag ) do\r\n    \tdef solution\r\n    \t\t1\r\n    \tend\r\n    end\r\n    Solution( :tag ) do\r\n    \tdef solution\r\n    \t\t2\r\n    \tend\r\n    end\r\n    Solution( :tag ) do\r\n    \tdef solution\r\n    \t\t3\r\n    \tend\r\n    end\r\n\r\n\r\n    class Client\r\n    \tinject Solution()\r\n\t\r\n    \tdef self.solve\r\n    \t\tSolution().tags.each { |e|\r\n    \t\t\tupdate e \r\n    \t\t\tputs new.solution rescue nil\r\n    \t\t}                              \r\n\t\t\r\n    \t\t# or...\r\n\t\t\r\n    \t\tsolutions = Solution().tags.each\r\n    \t\tbegin\r\n    \t\t\tupdate solutions.next\r\n    \t\t\tputs solved = new().solution()\r\n    \t\tend until solved\r\n    \t\tsolved\r\n    \tend\r\n\t\r\n    end\r\n\r\n    Client.solve\r\n\r\n\r\n### Injector Directives\r\nOnce you have an injector handle you can also use it to issue directives to the injector.  These directives can have a profound effect on your code.\r\n\r\n#### :collapse directive\r\nThis description produces similar results to the one for injector ejection (see above) except that further injector method calls DO NOT raise an error.  They just quietly return nil. Here are a couple of different cases:\r\n\r\nThe case with multiple objects\r\n\r\n  \tinjector :copiable do\r\n  \t\tdef object_copy\r\n  \t\t\t'a dubious copy'\r\n  \t\tend\r\n  \tend\r\n\r\n  \to1 = Object.new.enrich(copiable)\r\n  \to2 = Object.new.enrich(copiable)\r\n\r\n  \to1.object_copy.should == 'a dubious copy'\r\n  \to2.object_copy.should == 'a dubious copy'\r\n\r\n  \tcopiable :silence\r\n\r\n  \to1.object_copy.should == nil\r\n  \to2.object_copy.should == nil\r\n\r\n\r\nThe case with a class receiver:\r\n\r\n  \tclass SomeClass\r\n  \t\tinjector :code do\r\n  \t\t\tdef tester\r\n  \t\t\t\t'boo'\r\n  \t\t\tend\r\n  \t\tend\r\n\r\n  \t\tinject code\r\n  \tend\r\n\r\n  \ta = SomeClass.new\r\n  \tb = SomeClass.new\r\n\r\n  \t# collapse\r\n  \tSomeClass.code :collapse\r\n\r\n  \ta.tester.should == nil\r\n  \tb.tester.should == nil\r\n\r\n  \t# further\r\n  \tSomeClass.eject :code \r\n  \texpect{ a.tester }.to raise_error\r\n  \texpect{ b.tester }.to raise_error\r\n\r\n\r\n\r\n#### :rebuild directive\r\nInjectors that have been collapsed can at a later point then be reconstituted.  Here are a couple of cases:\r\n\r\nThe case with multiple object receivers:\r\n\r\n    injector :reenforcer do\r\n    \tdef thick_walls\r\n    \t\t'=====|||====='\r\n    \tend\r\n    end\r\n\r\n    o1 = Object.new.enrich(reenforcer)\r\n    o2 = Object.new.enrich(reenforcer)\r\n\r\n    reenforcer :collapse\r\n\r\n    o1.thick_walls.should == nil\r\n    o2.thick_walls.should == nil\r\n\r\n    reenforcer :rebuild\r\n\r\n    o1.thick_walls.should == '=====|||====='\r\n    o2.thick_walls.should == '=====|||====='\r\n\r\n\r\nThe case with a class receiver:\r\n\r\n  \tclass SomeBloatedObject\r\n  \t\tinjector :ThinFunction do\r\n  \t\t\tdef perform\r\n  \t\t\t\t'do the deed'\r\n  \t\t\tend\r\n  \t\tend\r\n  \t\tinject ThinFunction()\r\n  \tend\r\n  \tSomeBloatedObject.ThinFunction :silence  # alias to :collapse\r\n\r\n  \ttester = SomeBloatedObject.new\r\n  \ttester.perform.should == nil\r\n\r\n  \tSomeBloatedObject.ThinFunction :active   # alias to :rebuild\r\n  \ttester.perform.should == 'do the deed'\r\n  \t\r\n  \t\r\n#### :implode directive\r\nThis directive totally destroys the injector including the handle to it.  Use it carefully!\r\n\r\n    class Model\r\n    \tdef feature\r\n    \t\t'a standard feature'\r\n    \tend\r\n    end\r\n\r\n    injector :extras do\r\n    \tdef feature\r\n    \t\tsuper() + ' plus some extras'\r\n    \tend\r\n    end\r\n\r\n    car = Model.new.enrich(extras)\r\n    car.feature.should == 'a standard feature plus some extras'\r\n\r\n    extras :implode\r\n\r\n    # total implosion\r\n    car.feature.should == 'a standard feature'\r\n\r\n    expect{extras}.to raise_error(NameError, /extras/)\r\n    expect{ new_car = Model.new.enrich(extras) }.to raise_error(NameError, /extras/)\r\n    expect{\r\n    \textras do\r\n    \t\tdef foo\r\n    \t\tend\r\n    \tend\r\n    \t}.to raise_error(NameError, /extras/)\r\n\r\n\r\n\r\n---\r\nFor more information and additional examples see the rspec examples on this project.  There you'll find a long list of nearly __200__ rspec examples and code showcasing some additional features of Jackbox Injectors along with some additional descriptions.\r\n\r\n---\r\n## Additional Tools\r\nJackbox includes a couple of additional ancillary tools.  The first is an Abstract class base that prevents instantiation of the base class itself but not of its descendants.  The second is a persistent properties module named Prefs; it creates class/module/namespace level persistent properties.\r\n\r\nWith Abstract the code goes like this:\r\n\r\n    class Vector\r\n    \textend Abstract\r\n    \tdef speed\r\n    \t\t0\r\n    \tend\r\n    \tdef direction\r\n    \tend\r\n    end\r\n    expect{Vector.new}.to raise_error\r\n    \r\n    class Velocity < Vector\r\n    \tdef speed\r\n    \t\tsuper + 35\r\n    \tend\r\n    \tdef direction\r\n    \t\t:north\r\n    \tend\r\n    end\r\n    \r\n    expect{Velocity.new}.to_not raise_error\r\n    Velocity.new.speed.should == 35\r\n\r\n\r\nWith Prefs you can add persistent properties to a class.  These properties persist even through program termination. Here is the example code:\r\n\r\n    module Jester\r\n    \textend Prefs\r\n\t\r\n    \tpref :value => 10\r\n    end\r\n    \r\n    Jester.value.should == 10\r\n    Jester.value = 3\r\n    Jester.value.should == 3\r\n    Jester.reset :value\r\n    Jester.value.should == 10 \r\n  \r\nThere is also command line utility called **jackup** that simply allows users to bring their projects into a *\"Jackbox level\"*.  It inserts the right references and turns the targeted project into a bundler gem if it isn't already one also adding a couple of rake tasks.\r\n\r\n## Availability\r\n\r\nJackbox is current available for Linux, Mac, and Windows versions of Ruby 1.9.3 thru 2.2.1\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n    gem 'jackbox'\r\n\r\nAnd then execute:\r\n\r\n    $ bundle\r\n\r\nOr install it yourself as:\r\n\r\n    $ gem install jackbox\r\n    \r\nAnd then execute the following command inside the project directory:\r\n\r\n    $jackup \r\n    \r\n\r\n\r\n## Support\r\nAny questions/suggestions can be directed to the following email address: \r\n\r\n__service.delivered@ymail.com__.  \r\n\r\nPlease include your platform along with a description of the problem and any available stack trace.  Please keep in mind that, at this time we have limited staff and we will do our best to have a quick response time. \r\n\r\nAlso please follow us at http://jackbox.us\r\n\r\n## Licensing\r\n\r\nJackbox is currently free for anyone to **use**.\r\nCopyright © 2014, 2015 LHA. All rights reserved.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\nNON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\nIn the above copyright notice, the letters LHA are the english acronym \r\nfor Luis Enrique Alvarez (Barea) who is the author and owner of the copyright.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}